DOCS_ASSEMBLER = "<h1 id=\"assembler-instructions\">ASSEMBLER Instructions</h1>"
+"<p>This is a simple 2 pass assembler for the 65xx microprocessor. It is thought to accompany the emulator To get your source code compiled:</p>"
+"<ol>"
+"<li>Enter your src in \"source code\" pane.<ol start=\"2\">"
+"<li>Click the button \"generate\".</li>"
+"<li>Watch progress in \"listing\" pane.</li>"
+"<li>Copy code from \"object code\" pane.<br></li></ol></li>"
+"</ol>"
+"<h3 id=\"syntax\">Syntax</h3>"
+"<p>The assembler supports the following syntax:</p>"
+"<h4 id=\"opcodes-and-addressing\">Opcodes and Addressing</h4>"
+"<pre><code>  Opcodes are always 3 letter mnemonics followed by an (optional) operand/address:"
+"  OPC      ....   implied"
+" OPC A        ....   Accumulator"
+" OPC #BB      ....   immediate"
+" OPC HHLL     ....   absolute"
+" OPC HHLL,X   ....   absolute, X-indexed"
+" OPC HHLL,Y   ....   absolute, Y-indexed"
+" OPC *LL      ....   zeropage"
+" OPC *LL,X    ....   zeropage, X-indexed"
+" OPC *LL,Y    ....   zeropage, Y-indexed"
+" OPC (BB,X)   ....   X-indexed, indirect"
+" OPC (LL),Y   ....   indirect, Y-indexed"
+" OPC (HHLL)   ....   indirect"
+" OPC BB       ....   relative</code></pre>"
+"<p>Where HHLL is a 16bit word and LL or BB an 8 bit byte, and A is literal \"A\".<br />"
+"There must not be any white space in any part of an instruction's address.</p>"
+"<h4 id=\"number-formats\">Number Formats</h4>"
+"<pre><code>  $[0-9A-Fa-f] ....  hex"
+" %[01]        ....   binary"
+" 0[0-7]       ....   octal"
+" [0-9]        ....   decimal"
+" <            ....   LO-byte portion"
+" >            ....   HI-byte portion</code></pre>"
+"<h4 id=\"labels-and-identifiers\">Labels and Identifiers</h4>"
+"<p>Identifiers must begin with a letter [A-Z] and contain letters, digits, and the underscore [A-Z0-9_]. Only the first 6 characters are significant.</p>"
+"<p>All identifiers, numbers, opcodes, and pragmas are case insensitive and translated to upper case. Identifiers must not be the same as valid opcodes.</p>"
+"<p>The special identifier \"*\" refers to the program counter (PC).</p>"
+"<h5 id=\"exampels\">Exampels:</h5>"
+"<pre><code> * = $C000       ....   Set start address (PC) to C000."
+"org $C000     ....    (idem)"
+"LABEL1 LDA #4 ....    Define LABEL1 with address of instruction LDA."
+"BNE LABEL2    ....    Jump to address of label LABEL2."
+"STORE = $0800 ....    Define STORE with value 0800."
+"HERE = *      ....    Define HERE with current address (PC)."
+"HERE2         ....    Define HERE2 with current address (PC)."
+"LDA #         ....    Load LO-byte of VAL1.</code></pre>"
+"<h4 id=\"pragmas\">Pragmas</h4>"
+"<pre><code>  Pragmas start with a dot (.) and must be the only expression in a line:"
+"  .BYTE BB    ....    Insert 8 bit byte at current address into code."
+"  .WORD HHLL  ....    Insert 16 bit word at current address into code."
+"  .END    ....    End of source, stop assembly. (optional)</code></pre>"
+"<h4 id=\"comments\">Comments</h4>"
+"<pre><code>  ; comment   ....    Any sequence of characters after a semicolon util end of the line is ignored.</code></pre>"
+"<h4 id=\"white-space\">White Space</h4>"
+"<pre><code>  The assembler does not rely on any special formatting with following exclusion:</code></pre>"
+"<p>There must be white space between a label and a opcode and the opcode and any operands. Only one instruction per line is permitted.</p>"
+"<h4 id=\"code-example\">Code Example</h4>"
+"<h5 id=\"src\">Src:</h5>"
+"<pre><code>*=$c000"
+"         LDX #0"
+"  Label1 TXA"
+"         STA $0400,X"
+"       LDA #1"
+"       STA $D800,X"
+"       INX"
+"       BNE Label1"
+"       RTS"
+".END</code></pre>"
+"<h5 id=\"listing\">Listing:</h5>"
+"<pre><code> *=$C000"
+" C000        LDX #$00        A2 00"
+" C002 LABEL1 TXA             8A"
+" C003        STA $0400,X     9D 00 04"
+" C006        LDA #$01        A9 01"
+" C008        STA $D800,X     9D 00 D8"
+" C00B        INX             E8"
+" C00C        BNE LABEL1      D0 F4"
+" C00E        RTS             60"
+"  C00F .END</code></pre>"
+"<h5 id=\"object-code\">Object Code:</h5>"
+"<pre><code>  A2 00 8A 9D 00 04 A9 01"
+"  9D 00 D8 E8 D0 F4 60</code></pre>'

DOCS_DEBUGGER = "<h1 id=\"debugger-instructions\">DEBUGGER Instructions</h1>"
+"<h2 id=\"the-display\">The Display</h2>"
+"<p>The display shows all registers of a 6502/6510 CPU:</p>"
+"<pre><code>  PC  ....    Program Counter"
+"  A   ....    Accumulator"
+"  X   ....    X Register"
+"  Y   ....    Y Register"
+"  SR  ....    Status Register"
+"  SP  ....    Stack Pointer</code></pre>"
+"<p>The status register (SR) holds the following flags (from bit 7 to 0):</p>"
+"<pre><code>  N   ....    Negative"
+"  V   ....    Overflow"
+"  –   ....    ignored"
+"  B   ....    Break"
+"  D   ....    Decimal"
+"  I   ....    Interrupt (IRQ disable)"
+"  Z   ....    Zero"
+"  C   ....    Carry</code></pre>"
+"<p>The line disassembler shows the current value of PC, the content of the according memory address (the next instruction followed by the operands, if any), and a disassembly of this instruction.</p>"
+"<p>The cycle time display shows the ticks of exceeded CPU time (including extra cycles for branches page transitions).</p>"
+"<h2 id=\"setting-the-registers\">Setting the Registers</h2>"
+"<p>Click a registers label to set its value.<br />"
+"Click on a SR flag to flip its value.</p>"
+"<h2 id=\"memory\">Memory</h2>"
+"<p>The emulator implements 64 k of memory for the full 16 bit address range.<br />"
+"The 6502's stack of 1 k range is located at 0100 to 01FF (hard wired).</p>"
+"<h2 id=\"accessing-the-memory\">Accessing the Memory</h2>"
+"<p>The button \"look up mem #\" offers a quick inspection of a 16 byte range around any address.<br />"
+"You may enter any amount of hex code into the memory inspector's pane and load it to the specified start address.<br />"
+"Further the memory inspector lets you inspect the memory in steps of 128 (0x80) bytes (half page). You may alter the display's content and load it back the emulator's memory. (Any figures prefixed by a colon \":\" are ignored as line numbers.)<br />"
+"The \"show ASCII\" option shows the according ASCII characters at the left of each line (if applicable). Uncheck this when transfering memory to the disassembler.<br />"
+"Last there's an option to load the ROMs of the Commodore 64 (® CBM) to the according addresses (A000-BFFF, D000-FFFF) – for all those who can't help nostalgia. (Note: The emulator does not implement the C64's bank switching feature.)</p>"
+"<h2 id=\"about-the-debugger\">About the Debugger</h2>"
+"<p>The emulator is written in JavaScript and emulates a 65xx-family micro processor unit that was the heart of so popular micro computers as the Apple II (6502) or the Commedore 64 (6510). The most common types, the 6502 and 6510 processors, are basicly the same and share the same instruction tables. (The 6510 varies from 6502 only in the implementation of 6 I/O ports at addresses 0000 and 0001.)<br />"
+"The emulator implements all legal instructions. Undefined opcodes are ignored (treated as NOP, No OPeration, with cycle time 0) – no pseudo-opcodes are implemented.</p>'

DOCS_6502 = "<p>TODO</p>'
