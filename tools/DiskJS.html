<!--
//
// Copyright (c) 2024 Freddy Vandriessche.
// notice: https://raw.githubusercontent.com/RetroAppleJS/AppleII-IDE/main/LICENSE.md
//
//   ______     _          __          _____   ______   
//  |_   _ `.  (_)        [  |  _     |_   _|.' ____ \  
//    | | `. \ __   .--.   | | / ]      | |  | (___ \_| 
//    | |  | |[  | ( (`\]  | '' <   _   | |   _.____`.  
//   _| |_.' / | |  `'.'.  | |`\ \ | |__' |  | \____) | 
//  |______.' [___][\__) )[__|  \_]`.____.'   \______.'  
-->

<html style="background-color:#B0B0B0"><head>
  <title>APPLE II DISK TOOL - convert .dsk to .nib</title>
  <meta name="description" content="">
  <meta name="author" content="Freddy Vandriessche">
  <meta charset="utf-8"> 
  <link rel="stylesheet"        href="../res/COM_MAIN.css">
</head>

<script type="text/javascript" src="TOOLS_Header.js"></script>
<script type="text/javascript" src="../res/COM_MAIN.js"></script>
<script type="text/javascript" src="../res/EMU_appledisk2.js"></script>

<script>
var CONF_version="1.1.5"
var CONF_builddate="20231231-180000" 

var dsk_bytes = new Array();
var nib_dsk_bytes = new Array();
var HEX_PCT = Array(101);

function init_gui(_o)
{ 
  document.getElementById('slider_title').outerHTML = _TITLE();

  // initialise heat map colors
  //var col_arr = ["#430054","#403F87","#2D788E","#2CA984","#7DD552","#FDEA27"];
  var col_arr = ["#2D788E","#2CA984","#7DD552","#FDEA27"];
  //var col_arr = ["#0000FF","#44984C","#B6C41F","#FF9400","#FF0000","#FB94F8"];
  //var col_arr = ["#64D4FF","#8BDEDF","#8EDAA6","#BFD080","#F2C98F","#FEAC86"];

  for(var i=0;i<100;i++)
  {
      var rng = 100/(col_arr.length-1);
      var sec_idx = Math.floor(i/rng);                      // color range section index
      var sec_pct = Math.round(Math.floor(i%rng)*100/rng);  // interpolation percentage
      var rgb_rng = [ oCOM.HEX2RGB(col_arr[sec_idx]) , oCOM.HEX2RGB(col_arr[sec_idx+1]) ];
      HEX_PCT[i] = "#"+oCOM.RGB2HEX( interpolate_arr( rgb_rng[0] , rgb_rng[1] , sec_pct) ).join("");
      //document.write(i+" "+sec_idx+" "+sec_pct+" #"+HEX_PCT[i]+" <div style=height:20px;width:20px;background-color:"+HEX_PCT[i]+"></div><br>");
  }
  HEX_PCT[0] = "#000000"
  HEX_PCT[100] = col_arr[col_arr.length-1];
}







//  ███    ███  █████  ██ ███    ██      ██████ ██       █████  ███████ ███████ 
//  ████  ████ ██   ██ ██ ████   ██     ██      ██      ██   ██ ██      ██      
//  ██ ████ ██ ███████ ██ ██ ██  ██     ██      ██      ███████ ███████ ███████ 
//  ██  ██  ██ ██   ██ ██ ██  ██ ██     ██      ██      ██   ██      ██      ██ 
//  ██      ██ ██   ██ ██ ██   ████      ██████ ███████ ██   ██ ███████ ███████    


var oDISK = new function()
{
//  ██████  ██ ███████ ██   ██     ██████   █████  ██████  ███████ ███████ ██████  
//  ██   ██ ██ ██      ██  ██      ██   ██ ██   ██ ██   ██ ██      ██      ██   ██ 
//  ██   ██ ██ ███████ █████       ██████  ███████ ██████  ███████ █████   ██████  
//  ██   ██ ██      ██ ██  ██      ██      ██   ██ ██   ██      ██ ██      ██   ██ 
//  ██████  ██ ███████ ██   ██     ██      ██   ██ ██   ██ ███████ ███████ ██   ██ 

  this.DOS3_parse = function(dsk_data)
  {
    var geo = this.DOS3_m.DISK_GEO;
    var toc = this.DOS3_m.VTOC;
    var log_arr = new Array();

    var TRACK_SIZE =  geo.SECTOR_SIZE * geo.SECTORS_PER_TRACK;
    var disk_address_bits = Math.ceil(Math.log10(TRACK_SIZE*geo.TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);
    
    ////////////////////////////////////////
    // HIGHLITE VTOC SECTOR ON MEMORY MAP //
    ////////////////////////////////////////
 
    var track = sector = 0;
    var s = "";
    var table = document.getElementById("gtable_"+oMEMGRID.conf_grid.id_prefix);
    var addr_track = oCOM.getHexMulti(this.byte_offset(geo.VTOC_TRACK,0,geo),disk_address_digits); // find row position of VTOC
    for (var i = 0, row; row = table.rows[i]; i++)
    {
      var firstcol = row.cells[0].innerHTML;
      if(firstcol==addr_track)
          row.cells[0].innerHTML = "<font color='maroon'>"+firstcol+"<font>"; // colouring grid label
    }
    var el = document.getElementById(oMEMGRID.conf_grid.id_prefix + addr_track);
    if(el!=null) el.style.backgroundColor = "#FF8080";  // colouring grid cell
    


    //////////////////////////////
    // COLLECT VTOC INFORMATION //
    //////////////////////////////

    var track = geo.VTOC_TRACK;
    var sector = geo.VTOC_SECTOR;

    log_arr[log_arr.length] = "<font color='maroon'>";
    log_arr[log_arr.length] = "<b>VTOC PARSING RESULTS</b>"
    for(var r in toc)
    {
      // POPULATE VTOC DATA
      var rng_arr = this.HEXRange2Array(toc[r][0]);
      var _offset =  this.byte_offset(track,sector,geo);
      this.DOS3_m.VTOC[r][3] = dsk_data.slice( _offset+rng_arr[0] , _offset+rng_arr[rng_arr.length-1]+1 ); // take slice between first and last from range 

      // LOGGING
      var str = "";
      for(var _i=0 ; _i<rng_arr.length ; _i++)
      {
        if(toc[r][1]=="LEN" || toc[r][1]=="BEN") { n = toc[r][2][_i]*256 + toc[r][2][_i+1]; _i++ } // grab 2 values if big-endian or little-endian
        str += oFMT.fmtNumber( toc[r][3][_i] ,toc[r][1] ).str + " ";
      }
      log_arr[log_arr.length] = str + " = " + "<b>" + toc[r][2] + "</b>";
    }
    log_arr[log_arr.length] = "</font>";
    
    return {"data":this.DOS3_m,"logs":log_arr} 
  }

//  ██████  ██ ███████ ██   ██     ██ ██████  ███████ ███    ██ ████████ ██ ███████ ██ ███████ ██████  
//  ██   ██ ██ ██      ██  ██      ██ ██   ██ ██      ████   ██    ██    ██ ██      ██ ██      ██   ██ 
//  ██   ██ ██ ███████ █████       ██ ██   ██ █████   ██ ██  ██    ██    ██ █████   ██ █████   ██████  
//  ██   ██ ██      ██ ██  ██      ██ ██   ██ ██      ██  ██ ██    ██    ██ ██      ██ ██      ██   ██ 
//  ██████  ██ ███████ ██   ██     ██ ██████  ███████ ██   ████    ██    ██ ██      ██ ███████ ██   ██ 

  this.detect = function(dsk_data)
  {
    var result_arr = {};

    // check if DOS 3.3
    var pct = 0;
    var geo = this.DOS3_m.DISK_GEO;
    var offset_arr = this.HEXRange2Array( this.DOS3_m.VTOC.DOS_VER[0] );  // e.g. transforms "$04-$05" into [4,5]
    var DOS_VER = dsk_data[ this.byte_offset(geo.VTOC_TRACK,geo.VTOC_SECTOR,geo) + offset_arr[0] ];
    if(DOS_VER==3) pct += Math.round((1 - 1/255)*10000)/100;
    result_arr["DOS 3.3"] = pct;

    return result_arr;
  }

//  ██████  ███████ ██   ██     ██████      ███    ██ ██ ██████  
//  ██   ██ ██      ██  ██           ██     ████   ██ ██ ██   ██ 
//  ██   ██ ███████ █████        █████      ██ ██  ██ ██ ██████  
//  ██   ██      ██ ██  ██      ██          ██  ██ ██ ██ ██   ██ 
//  ██████  ███████ ██   ██     ███████     ██   ████ ██ ██████  

  this.convertDsk2Nib = function(dskBytes)
  {
      var sixTwo = [
          0x96, 0x97, 0x9a, 0x9b, 0x9d, 0x9e, 0x9f, 0xa6,
          0xa7, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb2, 0xb3,
          0xb4, 0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbc,
          0xbd, 0xbe, 0xbf, 0xcb, 0xcd, 0xce, 0xcf, 0xd3,
          0xd6, 0xd7, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,
          0xdf, 0xe5, 0xe6, 0xe7, 0xe9, 0xea, 0xeb, 0xec,
          0xed, 0xee, 0xef, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,
          0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff ];
      var secSkew = [ 0x0, 0x7, 0xe, 0x6, 0xd, 0x5, 0xc, 0x4, 0xb, 0x3, 0xa, 0x2, 0x9, 0x1, 0x8, 0xf ];
      var bytes = new Array(232960);
      var prenib = new Array(342);
      var offs;

      // Odd-even encoding for sector headers.
      function split_OddEven(b) { return [0xaa | (b >> 1),0xaa | b] }
      function join_OddEven(b1,b2) { return (((b1<<1)+1) & b2) }
      function addBytes(b_arr) { for(var i=0;i<b_arr.length;i++) bytes[offs++] = b_arr[i] }

      for (var track = 0; track < 35; track++) {
          offs = track * 6656;
          for (var sec = 0; sec < 16; sec++) {

              // 20 Sync bytes
              addBytes([0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff]);

              // Addr field prologue
              addBytes([0xd5,0xaa,0x96]);

              addBytes(split_OddEven(254));                 // Volume
              addBytes(split_OddEven(track));               // Track
              addBytes(split_OddEven(sec));                 // Sector
              addBytes(split_OddEven(254 ^ track ^ sec));   // Checksum

              // Addr field epilogue
              addBytes([0xde,0xaa,0xeb]);

              // 20 Sync bytes
              addBytes([0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff]);

              // Data field prologue
              addBytes([0xd5,0xaa,0xad]);

              // Start by prenibbilizing
              var doffs = secSkew[sec] * 256 + track * 4096;
              for (i = 0; i < 256; i++) {
                  var d8 = dskBytes[doffs + i];
                  prenib[i] = (d8 >> 2);

                  if (i < 86)
                      prenib[256 + 85 - i] =
                          ((d8 & 0x02) >> 1) | ((d8 & 0x01) << 1);
                  else if (i < 172)
                      prenib[256 + 171 - i] |=
                          (((d8 & 0x02) << 1) | ((d8 & 0x01) << 3));
                  else
                      prenib[256 + 257 - i] |=
                          (((d8 & 0x02) << 3) | ((d8 & 0x01) << 5));

                  if (i < 2)
                      prenib[257 - i] |=
                          (((d8 & 0x02) << 3) | ((d8 & 0x01) << 5));
              }

              // Encode nibbilized data.
              var prev = 0;
              for (i = 0; i < 86; i++) {
                  addBytes([ sixTwo[prev ^ prenib[256 + 85 - i]] ]);
                  prev = prenib[256 + 85 - i];
              }
              for (i = 0; i < 256; i++) {
                  addBytes([ sixTwo[prev ^ prenib[i]] ]);
                  prev = prenib[i];
              }
              addBytes([ sixTwo[prev] ]); // add one byte

              // Data field epilogue
              addBytes([0xde,0xaa,0xeb]);
          }

          // fill out with sync bytes until end of track.
          var bytes2EOT = (track+1) * 6656 - offs;
          addBytes( [...new Array(bytes2EOT)].map(()=> 0xff) );
      }
      return bytes;
  }




  this.byte_offset = function(track,sector,geo) { return track * geo.SECTOR_SIZE * geo.SECTORS_PER_TRACK + sector * geo.SECTOR_SIZE }

  this.HEXRange2Array = function(rng)
  {
    var txt = rng.replace(/\$/g,"");
    var lim = txt.split("-").length==2 ? [parseInt(txt.split("-")[0],16),parseInt(txt.split("-")[1],16)] : [parseInt(txt,16),parseInt(txt,16)];
    return Array.from({length:lim[1]-lim[0]+1}, (e, i)=>i+lim[0]);
  }

//  ███    ███ ███████ ████████  █████      ██████   █████  ████████  █████  
//  ████  ████ ██         ██    ██   ██     ██   ██ ██   ██    ██    ██   ██ 
//  ██ ████ ██ █████      ██    ███████     ██   ██ ███████    ██    ███████ 
//  ██  ██  ██ ██         ██    ██   ██     ██   ██ ██   ██    ██    ██   ██ 
//  ██      ██ ███████    ██    ██   ██     ██████  ██   ██    ██    ██   ██ 

  this.DOS3_m =
  {
    // GEOMETRY
    "DISK_GEO":
    {
       "SECTOR_SIZE":256
      ,"SECTORS_PER_TRACK":16
      ,"TRACKS_PER_DISK":35
      ,"VTOC_TRACK":17
      ,"VTOC_SECTOR":0
    }

    // LABELS
   ,"VTOC":
    {"U1":        ["$00"    ,"HEX","not used - usually $04"]
    ,"1CAT_T":    ["$01"    ,"DEC","track number of first catalog entry"]
    ,"1CAT_S":    ["$02"    ,"DEC","sector number of first catalog entry"]
    ,"DOS_VER":   ["$03"    ,"DEC","DOS release, as written by INIT (3 for DOS3.3)"]
    ,"U2":        ["$04-$05","HEX","not used"]
    ,"VOL":       ["$06"    ,"DEC","Disk volume number (1-254)"]
    ,"U3":        ["$07-$26","HEX","not used"]
    ,"TS_PAIRS":  ["$27"    ,"DEC","maximum number of track/sector pairs which will fit in one file track/sector list sector (122 for 256 byte sectors)"]
    ,"U4":        ["$28-$2F","HEX","not used"]
    ,"LCAT_T":    ["$30"    ,"DEC","last track where sectors were allocated"]
    ,"DIR_T":     ["$31"    ,"SIG","direction of track allocation (-1 inward, +1 outward)"]
    ,"U5":        ["$32-$33","HEX","not used"]
    ,"T":         ["$34"    ,"DEC","number of tracks per diskette (normally 35)"]
    ,"SIG":       ["$35"    ,"DEC","number of sectors per track (13 or 16)"]
    ,"BYTES_S":   ["$36-$37","LEN","number of bytes per sector (LO/HI format - normally $100)"]
    ,"BM0":       ["$38-$3B","BIN","bit map of free sectors in track 0"]
    ,"BM1":       ["$3C-$3F","BIN","bit map of free sectors in track 1"]
    ,"BM2":       ["$40-$43","BIN","bit map of free sectors in track 2"]
    ,"BM3":       ["$44-$47","BIN","bit map of free sectors in track 3"]
    ,"BM4":       ["$48-$4B","BIN","bit map of free sectors in track 4"]
    ,"BM5":       ["$4C-$4F","BIN","bit map of free sectors in track 5"]
    ,"BM6":       ["$50-$53","BIN","bit map of free sectors in track 6"]
    ,"BM7":       ["$54-$57","BIN","bit map of free sectors in track 7"]
    ,"BM8":       ["$58-$5B","BIN","bit map of free sectors in track 8"]
    ,"BM9":       ["$5C-$5F","BIN","bit map of free sectors in track 9"]
    ,"BM10":      ["$60-$63","BIN","bit map of free sectors in track 10"]
    ,"BM11":      ["$64-$67","BIN","bit map of free sectors in track 11"]
    ,"BM12":      ["$68-$6B","BIN","bit map of free sectors in track 12"]
    ,"BM13":      ["$6C-$6F","BIN","bit map of free sectors in track 13"]
    ,"BM14":      ["$70-$73","BIN","bit map of free sectors in track 14"]
    ,"BM15":      ["$74-$77","BIN","bit map of free sectors in track 15"]
    ,"BM16":      ["$78-$7B","BIN","bit map of free sectors in track 16"]
    ,"BM17":      ["$7C-$7F","BIN","bit map of free sectors in track 17"]
    ,"BM18":      ["$80-$83","BIN","bit map of free sectors in track 18"]
    ,"BM19":      ["$84-$87","BIN","bit map of free sectors in track 19"]
    ,"BM20":      ["$88-$8B","BIN","bit map of free sectors in track 20"]
    ,"BM21":      ["$8C-$8F","BIN","bit map of free sectors in track 21"]
    ,"BM22":      ["$90-$93","BIN","bit map of free sectors in track 22"]
    ,"BM23":      ["$94-$97","BIN","bit map of free sectors in track 23"]
    ,"BM24":      ["$98-$9B","BIN","bit map of free sectors in track 24"]
    ,"BM25":      ["$9C-$9F","BIN","bit map of free sectors in track 25"]
    ,"BM26":      ["$A0-$A3","BIN","bit map of free sectors in track 26"]
    ,"BM27":      ["$A4-$A7","BIN","bit map of free sectors in track 27"]
    ,"BM28":      ["$A8-$AB","BIN","bit map of free sectors in track 28"]
    ,"BM29":      ["$AC-$AF","BIN","bit map of free sectors in track 29"]
    ,"BM30":      ["$B0-$B3","BIN","bit map of free sectors in track 30"]
    ,"BM31":      ["$B4-$B7","BIN","bit map of free sectors in track 31"]
    ,"BM32":      ["$B8-$BB","BIN","bit map of free sectors in track 32"]
    ,"BM33":      ["$BC-$BF","BIN","bit map of free sectors in track 33"]
    ,"BM34":      ["$C0-$C3","BIN","bit map of free sectors in track 34"]
    ,"BM35N":     ["$C4-$FF","BIN","bit maps for additional tracks if there are more than 35 tracks per disk"]
    } 
  }
}





//  ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████ ███████  


 
//  ██████  ██ ███████ ██   ██     ██████  ██    ██ ███    ███ ██████  
//  ██   ██ ██ ██      ██  ██      ██   ██ ██    ██ ████  ████ ██   ██ 
//  ██   ██ ██ ███████ █████       ██   ██ ██    ██ ██ ████ ██ ██████  
//  ██   ██ ██      ██ ██  ██      ██   ██ ██    ██ ██  ██  ██ ██      
//  ██████  ██ ███████ ██   ██     ██████   ██████  ██      ██ ██      


function dumpdisk(bytes)
{
   /////////////
   // HEATMAP //
   /////////////

    var geo = oDISK.DOS3_m.DISK_GEO;
    var nulls = {"start":"","end":"","count":0,"max":256};
    var disk_address_bits = Math.ceil(Math.log10(geo.SECTOR_SIZE * geo.SECTORS_PER_TRACK * geo.TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);
    var disk_layout = { };

    // PREPARE HEATMAP DATA (in disk_layout)
    for(var _t=0;_t<geo.TRACKS_PER_DISK;_t++)  // ITERATE THROUGH TRACKS
    {   
        for(var _s=0;_s<geo.SECTORS_PER_TRACK;_s++)
        {
            // ITERATE THROUGH SECTORS
            var _offset = oDISK.byte_offset(_t,_s,geo)
            for(var _i=0;_i<geo.SECTOR_SIZE;_i++)
            {
                var idx = _offset + _i;
                var n = bytes[idx];
                if(n==0) nulls.count++; // count the nulls in one sector
            }
            nulls.start = oCOM.getHexMulti(_offset , disk_address_digits);
            nulls.end   = oCOM.getHexMulti(_offset + geo.SECTOR_SIZE , disk_address_digits);
            var pct = 100-Math.round((nulls.count/nulls.max)*100);
            var color = HEX_PCT[pct];
            disk_layout[nulls.start+"-"+nulls.end] = [color,"T$"+oCOM.getHexByte(_t)+" S$"+oCOM.getHexByte(_s)+" %"+Math.round(100*(1-nulls.count/256)),"DSK"];
            nulls.count = 0;
        }
    }
    // DISPLAY HEATMAP
    var linestep = 4096;  // 18 bits = 256 bytes per sector * 16 sectors per track * 35 tracks per side
    oMEMGRID.conf_grid.digits = disk_address_digits;
    el = document.getElementById("output");
    el.innerHTML = oMEMGRID.build_grid(34*linestep,35,-linestep);  // start, len, step, bits
    oMEMGRID.paint_grid(disk_layout);



   /////////////
   // LOGGING //
   /////////////

    var log_arr = [];
    var geo = oDISK.DOS3_m.DISK_GEO;
    var disk_address_bits = Math.ceil(Math.log10(geo.SECTOR_SIZE * geo.SECTORS_PER_TRACK * geo.TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);

    // LOGGING ONLY
    for(var _t=0;_t<geo.TRACKS_PER_DISK;_t++)  // ITERATE THROUGH TRACKS
    {
        log_arr[log_arr.length] = "track $"+oCOM.getHexByte(_t);
        for(var _s=0;_s<geo.SECTORS_PER_TRACK;_s++)  // ITERATE THROUGH SECTORS
        {
            log_arr[log_arr.length] = "sector $"+oCOM.getHexByte(_s);
            var _offset = oDISK.byte_offset(_t,_s,geo), s="";
            for(var idx=_offset; idx<_offset+geo.SECTOR_SIZE ; idx++)  // READ ENTIRE SECTOR
            {
                var n = bytes[idx];
                s += oCOM.getHexByte(n);  // dump 1 byte from disk
                if((idx%4)==3) s+= " ";   // add space each 4 bytes for readability
            }
            log_arr[log_arr.length] = "RAW SECTOR DATA ("+geo.SECTOR_SIZE+"bytes)";
            log_arr[log_arr.length] = s;
        }
    }
    document.getElementById('dump').innerHTML = log_arr.join("<br>")
}


//  ██████   █████  ██████  ███████ ███████     ██████  ██    ██ ████████ ████████  ██████  ███    ██ 
//  ██   ██ ██   ██ ██   ██ ██      ██          ██   ██ ██    ██    ██       ██    ██    ██ ████   ██ 
//  ██████  ███████ ██████  ███████ █████       ██████  ██    ██    ██       ██    ██    ██ ██ ██  ██ 
//  ██      ██   ██ ██   ██      ██ ██          ██   ██ ██    ██    ██       ██    ██    ██ ██  ██ ██ 
//  ██      ██   ██ ██   ██ ███████ ███████     ██████   ██████     ██       ██     ██████  ██   ████ 


function parsedisk(bytes)
{
  var log_arr = [];
  var detected = oDISK.detect(bytes);
  log_arr[log_arr.length] = detected["DOS 3.3"]+"% likely DOS 3.3";

  if(detected["DOS 3.3"]>99)
  {
    var _o = oDISK.DOS3_parse(bytes);    // PARSE DISK DATA
    log_arr.push(_o.logs.join("<br>"));
  }
  //else if(_s==0) log_arr[log_arr.length] = "<br>PARSER SKIPPED - POOR MATCH<br>";
  
  document.getElementById('dump').innerHTML = log_arr.join("<br>");
}


//  ██████   ██████  ██     ██ ███    ██ ██       ██████   █████  ██████         ███    ██ ██ ██████  
//  ██   ██ ██    ██ ██     ██ ████   ██ ██      ██    ██ ██   ██ ██   ██        ████   ██ ██ ██   ██ 
//  ██   ██ ██    ██ ██  █  ██ ██ ██  ██ ██      ██    ██ ███████ ██   ██        ██ ██  ██ ██ ██████  
//  ██   ██ ██    ██ ██ ███ ██ ██  ██ ██ ██      ██    ██ ██   ██ ██   ██        ██  ██ ██ ██ ██   ██ 
//  ██████   ██████   ███ ███  ██   ████ ███████  ██████  ██   ██ ██████      ██ ██   ████ ██ ██████  



function download_nib()
{
  nib_dsk_bytes = oEMU.component.IO["AppleDisk"].convertDsk2Nib(oCOM.UploadData); 
  // nib_dsk_bytes = apple2ConvertDskToNib(oCOM.UploadData);
  var fileName = oCOM.UploadName.replace(".DSK",".NIB").replace(".dsk",".nib"); 
  oCOM.Download(fileName,nib_dsk_bytes);
}

//   ██████   ██████ ██████      ██       ██████   ██████  ██   ██ ██    ██ ██████  
//  ██       ██      ██   ██     ██      ██    ██ ██    ██ ██  ██  ██    ██ ██   ██ 
//  ██   ███ ██      ██████      ██      ██    ██ ██    ██ █████   ██    ██ ██████  
//  ██    ██ ██      ██   ██     ██      ██    ██ ██    ██ ██  ██  ██    ██ ██      
//   ██████   ██████ ██   ██     ███████  ██████   ██████  ██   ██  ██████  ██      

function GCR_lookup(fmt)
{
  var s = new Array();
  var tbl = new Array();
  switch(fmt)
  {
    case "16-sector":
      s[s.length]  = "<div style='overflow:scroll; height:400px;'>"
      s[s.length] = "CALCULATION FROM SCRATCH"
      var j = 0;
      for(var i=128;i<256;i++)
      {
        var str = oCOM.getBinMulti(i,8);
        if(str.indexOf("000")<0) 
        { 
          s[s.length] = (j++)+" "+str+" "+oCOM.getHexByte(i);
        }
      }

      s[s.length] = "--------------"

      var str = "00>036C 01>036D 02>0370 03>0371 04>0373 " 
      +"05>0374 06>0375 07>037C 08>037D 09>0381 "
      +"0A>0382 0B>0383 0C>0384 0D>0385 0E>0388 "
      +"0F>0389 10>038A 11>038B 12>038C 13>038D "
      +"14>038F 15>0390 16>0391 17>0392 18>0393 "
      +"19>0394 1A>0395 1B>03A1 1C>03A3 1D>03A4 "
      +"1E>03A5 1F>03A9 20>03AC 21>03AD 22>03AF "
      +"23>03B0 24>03B1 25>03B2 26>03B3 27>03B4 "
      +"28>03B5 29>03BB 2A>03BC 2B>03BD 2C>03BF "
      +"2D>03C0 2E>03C1 2F>03C2 30>03C3 31>03C4 "
      +"32>03C5 33>03C8 34>03C9 35>03CA 36>03CB "
      +"37>03CC 38>03CD 39>03CF 3A>03D0 3B>03D1 "
      +"3C>03D2 3D>03D3 3E>03D4 3F>03D5"

      s[s.length] = "EXTRACT FROM ROM"
      var j = 0;
      var sa = str.split(" ");
      for(var i=0;i<sa.length;i++)
      {
        var d =  oCOM.base_convert(sa[i].split(">")[1],["0123456789ABCDEF"],["0123456789"])
        var e = (d-876)+0x96;
        s[s.length] = (j++)+" "+oCOM.getBinMulti(e,8) +" "+ oCOM.getHexByte(e);
      }
      s[s.length]  = "</div>"
    break;
  }

  return s;
}

// ████████  █████  ██ ██          ███████ ██    ██ ███    ██  ██████ ████████ ██  ██████  ███    ██ ███████ 
//    ██    ██   ██ ██ ██          ██      ██    ██ ████   ██ ██         ██    ██ ██    ██ ████   ██ ██      
//    ██    ███████ ██ ██          █████   ██    ██ ██ ██  ██ ██         ██    ██ ██    ██ ██ ██  ██ ███████ 
//    ██    ██   ██ ██ ██          ██      ██    ██ ██  ██ ██ ██         ██    ██ ██    ██ ██  ██ ██      ██ 
//    ██    ██   ██ ██ ███████     ██       ██████  ██   ████  ██████    ██    ██  ██████  ██   ████ ███████

var oFMT = new function()
{
  this.fmtNumber = function(num,fmt)
  {
    var r = {"val":num,"str":"","bytes":Math.floor(num/256)+1,"fmt":fmt}
    switch(r.fmt)
    {
      case "HEX": r.str = "$"+oCOM.getHexMulti(r.val,r.bytes*2); return r; // hex
      case "DEC": r.str = r.val+""; return r;                              // unsigned decimal
      case "SIG": r.str = (~r.val)+1; return r;                            // inverse 2's complement !!
      case "LEN": r.str = ((r.val>>8)&0xFF) + (r.val&0xFF)*256; return r;  // Little-endian unsigned decimal
      case "BEN": r.str = ((r.val>>8)&0xFF)*256 + (r.val&0xFF); return r;  // Big-endian unsigned decimal
      case "BIN": r.str = "%"+oCOM.getBinMulti(r.val,r.bytes*8); return r; // binary
      default: 
        return this.fmtExtension(r,fmt);
    }
  }
  this.fmtExtension = function(r,fmt) { return r }
}

function interpolate_arr(arr1,arr2,pct)
{
  var arr = Array(arr1.length);
  for(var i=0;i<arr.length;i++)
    arr[i] = Math.round(arr1[i] + (arr2[i]-arr1[i])*pct/100);
  return arr;
}


</script>


<!--
   ____    ____          _            
  |_   \  /   _|        (_)           
    |   \/   |   ,--.   __   _ .--.   
    | |\  /| |  `'_\ : [  | [ `.-. |  
   _| |_\/_| |_ // | |, | |  | | | |  
  |_____||_____|\'-;__/[___][___||__]
  ██   ██ ████████ ███    ███ ██      
  ██   ██    ██    ████  ████ ██      
  ███████    ██    ██ ████ ██ ██      
  ██   ██    ██    ██  ██  ██ ██      
  ██   ██    ██    ██      ██ ███████ 
-->  

<body class="slider_main" onload="init_gui();">

  <div id="slider_title"></div>
  <div class="slider_overlay">
    <div id="topmenu">
      <ul id="minitabs">
        <li><input type="file" id="loadfile" value="Disk" onchange="oCOM.Upload('loadfile',dumpdisk);" accept=".dsk"></li>
        <li><img onMouseOver="this.style.cursor='pointer'" onclick="document.getElementById('dump').innerHTML=parsedisk(oCOM.UploadData).join('<br>');" src='data:image/gif;base64,R0lGODlhGAAYAPAAAF3/AAAAACH5BAEAAAAALAAAAAAYABgAAAJPhG+hiu0Y4JsnSvqsBRvXtHXVQmpM4ogN+V1T2aJcSZ9cW+c4mNOf2fOBeEHWcFZc/IjFHbIpu1FgUelLWX1SsVaPKeaRhsKubLijOhspBQA7'></li>
        <li><button onclick="download_nib()">Download .NIB</button></li>
        <li>&nbsp;&nbsp;
          <a target=_blank href="http://fileformats.archiveteam.org/wiki/Apple_DOS_file_system">[docs]</a>
          <a target=_blank href="http://mirrors.apple2.org.za/apple.cabi.net/FAQs.and.INFO/A2.CSA2.FAQS.IN.HTML/apple.II.dos.and.prodos.mi.html">[more]</a></li>
          <li><button onclick="document.getElementById('output').innerHTML+=GCR_lookup('16-sector').join('<br>')">GCR table</button></li>
      </ul>
    </div>
    <div id=main style="width:100%;height:100%;background: linear-gradient(180deg, rgba(220,220,220,1) 0%, rgba(251,251,251,1) 50%);">
      <table>
      <tr>
        <td><img style="margin:20px;width:256px;float:left;image-rendering:pixelated;" src="../res/apple-disk-ii_256.png"></td>
        <td rowspan="2" valign="top"><div id="output"></div></td>
      </tr>
      <tr>
          <td><div id="dump" style="font-size:x-small;width:296px;height:120px;float:left;overflow-x:hidden;overflow-y:auto;"></div></td>
      </tr>
      </table>
    </div>
  </div>

</body>
</html>
