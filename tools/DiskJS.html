<html style="background-color:#B0B0B0"><head>
  <title>APPLE II DISK TOOL - convert .dsk to .nib</title>
  <meta name="description" content="">
  <meta name="author" content="Freddy Vandriessche">
  <meta charset="utf-8"> 
  <link rel="stylesheet"        href="../res/COM_MAIN.css">
</head>

<script type="text/javascript" src="TOOLS_Header.js"></script>
<script type="text/javascript" src="../res/COM_MAIN.js"></script>
<script type="text/javascript" src="../res/EMU_apple2main.js"></script>

<script>
var CONF_version="1.1.2"
var CONF_builddate="20231231-180000" 

var dsk_bytes = new Array();
var nib_dsk_bytes = new Array();
var SECTOR_SIZE = 256;
var SECTORS_PER_TRACK = 16;
var TRACKS_PER_DISK = 35;
var VTOC_TRACK = 17; 
var VTOC_SECTOR = 0; 
var HEX_PCT = Array(101);

function init_gui(_o) { 
  document.getElementById('slider_title').outerHTML = _TITLE();

  // initialise heat map colors
  //var col_arr = ["#430054","#403F87","#2D788E","#2CA984","#7DD552","#FDEA27"];
  var col_arr = ["#2D788E","#2CA984","#7DD552","#FDEA27"];
  //var col_arr = ["#0000FF","#44984C","#B6C41F","#FF9400","#FF0000","#FB94F8"];
  //var col_arr = ["#64D4FF","#8BDEDF","#8EDAA6","#BFD080","#F2C98F","#FEAC86"];

  for(var i=0;i<100;i++)
  {
      var rng = 100/(col_arr.length-1);
      var sec_idx = Math.floor(i/rng);                      // color range section index
      var sec_pct = Math.round(Math.floor(i%rng)*100/rng);  // interpolation percentage
      var rgb_rng = [ oCOM.HEX2RGB(col_arr[sec_idx]) , oCOM.HEX2RGB(col_arr[sec_idx+1]) ];
      HEX_PCT[i] = "#"+oCOM.RGB2HEX( interpolate_arr( rgb_rng[0] , rgb_rng[1] , sec_pct) ).join("");
      //document.write(i+" "+sec_idx+" "+sec_pct+" #"+HEX_PCT[i]+" <div style=height:20px;width:20px;background-color:"+HEX_PCT[i]+"></div><br>");
  }
  HEX_PCT[0] = "#000000"
  HEX_PCT[100] = col_arr[col_arr.length-1];
}

function interpolate_arr(arr1,arr2,pct)
{
  var arr = Array(arr1.length);
  for(var i=0;i<arr.length;i++)
    arr[i] = Math.round(arr1[i] + (arr2[i]-arr1[i])*pct/100);
  return arr;
}

function dl()
{
  nib_dsk_bytes = apple2ConvertDskToNib(oCOM.UploadData);
  var fileName = oCOM.UploadName.replace(".DSK",".NIB").replace(".dsk",".nib"); 
  oCOM.Download(fileName,nib_dsk_bytes);
}

var oDISK = new function()
{
  this.DOS3_parse = function(track,sector,dsk_data)
  {
    var geo = this.DOS3_m.DISK_GEO;
    var toc = this.DOS3_m.VTOC;
    var log_arr = new Array();

    var TRACK_SIZE =  geo.SECTOR_SIZE * geo.SECTORS_PER_TRACK;
    var disk_address_bits = Math.ceil(Math.log10(TRACK_SIZE*geo.TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);
    
    // HIGHLITE VTOC SECTOR
    if(track==0 && sector==0)
    {
      var s = "";
      var table = document.getElementById("gtable_"+oMEMGRID.conf_grid.id_prefix);
      var addr_track = oCOM.getHexMulti(geo.VTOC_TRACK * TRACK_SIZE,disk_address_digits); // find row position of VTOC
      for (var i = 0, row; row = table.rows[i]; i++)
      {
        var firstcol = row.cells[0].innerHTML;
        if(firstcol==addr_track)
            row.cells[0].innerHTML = "<font color='maroon'>"+firstcol+"<font>"; // colouring grid label
      }
      var el = document.getElementById(oMEMGRID.conf_grid.id_prefix + addr_track);
      if(el!=null) el.style.backgroundColor = "#FF8080";  // colouring grid cell
    }

    // PARSE Volume Table of Contents (VTOC)
    if(track == geo.VTOC_TRACK && sector == geo.VTOC_SECTOR)  
    {
      log_arr[log_arr.length] = "<font color='maroon'>";
      for(var r in toc)
      {
        var rng = toc[r][0]
        var rng_txt = rng.replace(/\$/g,"");
        var rng_pair = rng_txt.split("-").length==2 ? [parseInt(rng_txt.split("-")[0],16),parseInt(rng_txt.split("-")[1],16)] : [parseInt(rng_txt,16),parseInt(rng_txt,16)];
        var sec_idx = track * TRACK_SIZE + sector * SECTOR_SIZE
        toc[r][3] = dsk_data.slice(sec_idx+rng_pair[0],sec_idx+rng_pair[1]+1);

        var str = "";
        for(var _offset=0 ; _offset<toc[r][3].length ; _offset++)
        {
          var n = toc[r][3][_offset];
          if(toc[r][1]=="LEN" || toc[r][1]=="BEN") { n = toc[r][2][_offset]*256 + toc[r][2][_offset+1]; _offset++ }
          str += oFMT.fmtNumber( n ,toc[r][1] ).str + " ";
        }
        log_arr[log_arr.length] = str + " = " + "<b>" + toc[r][2] + "</b>";
      }
      log_arr[log_arr.length] = "</font>";
    }
    return {"data":this.DOS3_m,"logs":log_arr} 
  }

  // META DATA
  this.DOS3_m =
  {
    // GEOMETRY
    "DISK_GEO":
    {
       "SECTOR_SIZE":256
      ,"SECTORS_PER_TRACK":16
      ,"TRACKS_PER_DISK":35
      ,"VTOC_TRACK":17
      ,"VTOC_SECTOR":0
    }

    // LABELS
   ,"VTOC":
    {"U1":        ["$00"    ,"HEX","not used - usually $04"]
    ,"1CAT_T":    ["$01"    ,"DEC","track number of first catalog sector"]
    ,"1CAT_S":    ["$02"    ,"DEC","sector number of first catalog sector"]
    ,"DOS_VER":   ["$03"    ,"DEC","DOS release, as written by INIT (3 for DOS3.3)"]
    ,"U2":        ["$04-$05","HEX","not used"]
    ,"VOL":       ["$06"    ,"DEC","Disk volume number (1-254)"]
    ,"U3":        ["$07-$26","HEX","not used"]
    ,"TS_PAIRS":  ["$27"    ,"DEC","maximum number of track/sector pairs which will fit in one file track/sector list sector (122 for 256 byte sectors)"]
    ,"U4":        ["$28-$2F","HEX","not used"]
    ,"LCAT_T":    ["$30"    ,"DEC","last track where sectors were allocated"]
    ,"DIR_T":     ["$31"    ,"SIG","direction of track allocation (-1 inward, +1 outward)"]
    ,"U5":        ["$32-$33","HEX","not used"]
    ,"T":         ["$34"    ,"DEC","number of tracks per diskette (normally 35)"]
    ,"SIG":       ["$35"    ,"DEC","number of sectors per track (13 or 16)"]
    ,"BYTES_S":   ["$36-$37","LEN","number of bytes per sector (LO/HI format - normally $100)"]
    ,"BM0":       ["$38-$3B","BIN","bit map of free sectors in track 0"]
    ,"BM1":       ["$3C-$3F","BIN","bit map of free sectors in track 1"]
    ,"BM2":       ["$40-$43","BIN","bit map of free sectors in track 2"]
    ,"BM3":       ["$44-$47","BIN","bit map of free sectors in track 3"]
    ,"BM4":       ["$48-$4B","BIN","bit map of free sectors in track 4"]
    ,"BM5":       ["$4C-$4F","BIN","bit map of free sectors in track 5"]
    ,"BM6":       ["$50-$53","BIN","bit map of free sectors in track 6"]
    ,"BM7":       ["$54-$57","BIN","bit map of free sectors in track 7"]
    ,"BM8":       ["$58-$5B","BIN","bit map of free sectors in track 8"]
    ,"BM9":       ["$5C-$5F","BIN","bit map of free sectors in track 9"]
    ,"BM10":      ["$60-$63","BIN","bit map of free sectors in track 10"]
    ,"BM11":      ["$64-$67","BIN","bit map of free sectors in track 11"]
    ,"BM12":      ["$68-$6B","BIN","bit map of free sectors in track 12"]
    ,"BM13":      ["$6C-$6F","BIN","bit map of free sectors in track 13"]
    ,"BM14":      ["$70-$73","BIN","bit map of free sectors in track 14"]
    ,"BM15":      ["$74-$77","BIN","bit map of free sectors in track 15"]
    ,"BM16":      ["$78-$7B","BIN","bit map of free sectors in track 16"]
    ,"BM17":      ["$7C-$7F","BIN","bit map of free sectors in track 17"]
    ,"BM18":      ["$80-$83","BIN","bit map of free sectors in track 18"]
    ,"BM19":      ["$84-$87","BIN","bit map of free sectors in track 19"]
    ,"BM20":      ["$88-$8B","BIN","bit map of free sectors in track 20"]
    ,"BM21":      ["$8C-$8F","BIN","bit map of free sectors in track 21"]
    ,"BM22":      ["$90-$93","BIN","bit map of free sectors in track 22"]
    ,"BM23":      ["$94-$97","BIN","bit map of free sectors in track 23"]
    ,"BM24":      ["$98-$9B","BIN","bit map of free sectors in track 24"]
    ,"BM25":      ["$9C-$9F","BIN","bit map of free sectors in track 25"]
    ,"BM26":      ["$A0-$A3","BIN","bit map of free sectors in track 26"]
    ,"BM27":      ["$A4-$A7","BIN","bit map of free sectors in track 27"]
    ,"BM28":      ["$A8-$AB","BIN","bit map of free sectors in track 28"]
    ,"BM29":      ["$AC-$AF","BIN","bit map of free sectors in track 29"]
    ,"BM30":      ["$B0-$B3","BIN","bit map of free sectors in track 30"]
    ,"BM31":      ["$B4-$B7","BIN","bit map of free sectors in track 31"]
    ,"BM32":      ["$B8-$BB","BIN","bit map of free sectors in track 32"]
    ,"BM33":      ["$BC-$BF","BIN","bit map of free sectors in track 33"]
    ,"BM34":      ["$C0-$C3","BIN","bit map of free sectors in track 34"]
    ,"BM35N":     ["$C4-$FF","BIN","bit maps for additional tracks if there are more than 35 tracks per disk"]
    } 
  }
}

var oFMT = new function()
{
  this.fmtNumber = function(num,fmt)
  {
    var r = {"val":num,"str":"","bytes":Math.floor(num/256)+1,"fmt":fmt}
    switch(r.fmt)
    {
      case "HEX": r.str = "$"+oCOM.getHexMulti(r.val,r.bytes*2); return r; // hex
      case "DEC": r.str = r.val+""; return r;                              // unsigned decimal
      case "SIG": r.str = (~r.val)+1; return r;                            // inverse 2's complement !!
      case "LEN": r.str = ((r.val>>8)&0xFF) + (r.val&0xFF)*256; return r;  // Little-endian unsigned decimal
      case "BEN": r.str = ((r.val>>8)&0xFF)*256 + (r.val&0xFF); return r;  // Big-endian unsigned decimal
      case "BIN": r.str = "%"+oCOM.getBinMulti(r.val,r.bytes*8); return r; // binary
      default: 
        return this.fmtExtension(r,fmt);
    }
  }
  this.fmtExtension = function(r,fmt) { return r }
}

function dumpdisk(bytes)
{
    var log_arr = [];
    var nulls = {"start":"","end":"","count":0};
    var TRACK_SIZE =  SECTOR_SIZE * SECTORS_PER_TRACK;
    var disk_address_bits = Math.ceil(Math.log10(TRACK_SIZE*TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);

    for(var _t=0;_t<TRACKS_PER_DISK;_t++)  // ITERATE THROUGH TRACKS
    {
        log_arr[log_arr.length] = "track $"+oCOM.getHexByte(_t);
        for(var _s=0;_s<SECTORS_PER_TRACK;_s++)  // ITERATE THROUGH SECTORS
        {
            log_arr[log_arr.length] = "sector $"+oCOM.getHexByte(_s);
            var s = "";
            for(var _offset=0;_offset<SECTOR_SIZE;_offset++)  // ITERATE THROUGH BYTES IN SECTOR
            {
                var idx = _t * TRACK_SIZE + _s * SECTOR_SIZE + _offset;
                var n = bytes[idx];
                if(n==0) nulls.count++
                s += oCOM.getHexByte(n);  // dump 1 byte from disk
                if((idx%4)==3) s+= " ";
            }

            nulls.start = oCOM.getHexMulti(_t*TRACK_SIZE + _s*SECTOR_SIZE,disk_address_digits);
            nulls.end   = oCOM.getHexMulti((_t*TRACK_SIZE + _s*SECTOR_SIZE + SECTOR_SIZE),disk_address_digits);
            var color = "#"+oCOM.getHexMulti(255-nulls.count,2)+oCOM.getHexMulti(255-nulls.count,2)+"00";
            disk_layout[nulls.start+"-"+nulls.end] = [color,"Disk "+oCOM.getHexMulti(nulls.count,2),"DSK"];
            log_arr[log_arr.length] = 'layout["'+nulls.start+"-"+nulls.end+'"] = ["'+color+'","Disk '+oCOM.getHexMulti(nulls.count,2)+',"DSK"]';

            log_arr[log_arr.length] = "RAW SECTOR DATA ("+SECTOR_SIZE+"bytes)";
            log_arr[log_arr.length] = s;

            var _o = oDISK.DOS3_parse(_t,_s,bytes);    // PARSE DISK DATA

            log_arr.push(_o.logs.join("<br>"));
            nulls.count = 0;
        } 
    }
    return log_arr;
}

function dumpdisk_GRID(bytes)
{
    var nulls = {"start":"","end":"","count":0,"max":256};
    var TRACK_SIZE =  SECTOR_SIZE * SECTORS_PER_TRACK;
    var disk_address_bits = Math.ceil(Math.log10(TRACK_SIZE*TRACKS_PER_DISK) / Math.log10(2));
    var disk_address_digits = Math.ceil(disk_address_bits/4);
    for(var _t=0;_t<TRACKS_PER_DISK;_t++)  // ITERATE THROUGH TRACKS
    {   
        for(var _s=0;_s<SECTORS_PER_TRACK;_s++)
        {
            // ITERATE THROUGH SECTORS
            for(var _offset=0;_offset<SECTOR_SIZE;_offset++)
            {
                var idx = _t * TRACK_SIZE + _s * SECTOR_SIZE + _offset;
                var n = bytes[idx];
                if(n==0) nulls.count++; // count the nulls in one sector
            }
            //if(nulls.count>127) nulls.count--; // mitigate overflow (hex goes back to 00 if 256)
            nulls.start = oCOM.getHexMulti(_t*TRACK_SIZE + _s*SECTOR_SIZE,disk_address_digits);
            nulls.end   = oCOM.getHexMulti((_t*TRACK_SIZE + _s*SECTOR_SIZE + SECTOR_SIZE),disk_address_digits);
            var pct = 100-Math.round((nulls.count/nulls.max)*100);
            var color = HEX_PCT[pct];
            disk_layout[nulls.start+"-"+nulls.end] = [color,"T$"+oCOM.getHexByte(_t)+" S$"+oCOM.getHexByte(_s)+" %"+Math.round(100*(1-nulls.count/256)),"DSK"];
            nulls.count = 0;
        }
    }
    var linestep = 4096;  // 18 bits = 256 bytes per sector * 16 sectors per track * 35 tracks per side
    oMEMGRID.conf_grid.digits = disk_address_digits;
    el = document.getElementById("output");
    el.innerHTML = oMEMGRID.build_grid(34*linestep,35,-linestep);  // start, len, step, bits
    oMEMGRID.paint_grid(disk_layout);
    //document.write(s)
}

var disk_layout = { }
</script>

<body class="slider_main" onload="init_gui();">

  <div id="slider_title"></div>
  <div class="slider_overlay">
    <div id="topmenu">
      <ul id="minitabs">
        <li><input type="file" id="loadfile" value="Disk" onchange="oCOM.Upload('loadfile',dumpdisk_GRID);" accept=".dsk"></li>
        <li><img onMouseOver="this.style.cursor='pointer'" onclick="document.getElementById('dump').innerHTML=dumpdisk(oCOM.UploadData).join('<br>');" src='data:image/gif;base64,R0lGODlhGAAYAPAAAF3/AAAAACH5BAEAAAAALAAAAAAYABgAAAJPhG+hiu0Y4JsnSvqsBRvXtHXVQmpM4ogN+V1T2aJcSZ9cW+c4mNOf2fOBeEHWcFZc/IjFHbIpu1FgUelLWX1SsVaPKeaRhsKubLijOhspBQA7'></li>
        <li><button onclick="dl()">Download .NIB</button></li>
        <li>&nbsp;&nbsp;<a target=_blank href="http://fileformats.archiveteam.org/wiki/Apple_DOS_file_system">[docs]</a>
                        <a target=_blank href="http://mirrors.apple2.org.za/apple.cabi.net/FAQs.and.INFO/A2.CSA2.FAQS.IN.HTML/apple.II.dos.and.prodos.mi.html">[more]</a></li>
      </ul>
    </div>
    <div id=main style="width:100%;height:100%;background: linear-gradient(180deg, rgba(220,220,220,1) 0%, rgba(251,251,251,1) 50%);">
      <table>
      <tr>
        <td><img style="margin:20px;width:256px;float:left;image-rendering:pixelated;" src="../res/apple-disk-ii_256.png"></td>
        <td rowspan="2" valign="top"><div id="output"></div></td>
      </tr>
      <tr>
          <td><div id="dump" style="font-size:x-small;width:296px;height:120px;float:left;overflow-x:hidden;overflow-y:auto;"></div></td>
      </tr>
      </table>
    </div>
  </div>

</body>
</html>