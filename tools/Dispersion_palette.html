<head>
  <title>Draw Rainbow with Linear gradient</title>
    <style type="text/css">
        body { font-family: 'Courier'; font-size: 12px; }
        #Debugcanvas { border:1px solid black; }
        #Mycanvas { border:1px solid black; }
        #Mycanvas2 { border:1px solid black; }
        .slider { display: inline-block; }
    </style>
<script type="text/javascript">

var bUpdate  = true;        // screen update trigger
var oPALETTE = new PALETTE();
oPALETTE.load(["#682172","#68350D","#174A72","#97DD8C","#E7A1F2","#E7B48C","#97CAF2","#7F7F7F","#7F931A","#2FA87F","#D0567F","#7F6CE5"])

function PALETTE()
{
    this.bDebug      = false;
    this.color_depth = 12;    // source color depth
    this.dot_size    = 10;
    this.sec_n       = [7,8]; // sections to show vs total sections
    this.canvas      = [];
    this.ctx         = [];

    this.load        = function(p) { this.hex_pal = p }
    this.debug_data  = {};
    this.debug_save  = function(arg)
    { 
        for(var i in arg)
        {
            if(!this.debug_data[i]) this.debug_data[i] = [];
            this.debug_data[i][ this.debug_data[i].length ] = arg[i]; 
        }
    }; 
    this.clear_layer        = function(n) { this.ctx[n].clearRect(0, 0, this.canvas[n].width, this.canvas[n].height) }
    this.drawPixel          = function(context, x, y, color)
    {
        var roundedX = Math.round(x);
        var roundedY = Math.round(y);

        context.beginPath();
        context.fillStyle = color || '#000';
        context.fillRect(roundedX, roundedY, 1, 1);
        context.fill();
    }
    this.insert_canvas = function(arg)
    {
        var anchor = document.getElementById(arg.id);
        this.canvas = [ document.createElement('canvas'),document.createElement('canvas') ];

        this.canvas[0].id = "Mycanvas";
        this.canvas[0].width = arg.width;
        this.canvas[0].height = arg.height;
        this.canvas[0].style.zIndex = 0;
        this.canvas[0].style.position = "absolute";
        this.canvas[0].style.top = "58px";
        anchor.appendChild(this.canvas[0]);

        this.canvas[1].id = "Mycanvas2";
        this.canvas[1].width = arg.width;
        this.canvas[1].height = arg.height;
        this.canvas[1].style.zIndex = 1;
        this.canvas[1].style.position = "absolute";
        this.canvas[1].style.top = "58px";
        this.canvas[1].addEventListener('click', 
        function(event)
        {
            x = event.offsetX;
            y = event.offsetY;
            var imageData = oPALETTE.ctx[0].getImageData(x, y, 1, 1).data;
            alert("("+x+","+y+") #"+oPALETTE.RGB2HEX(imageData).join(""))
        }
        ,false);   
        anchor.appendChild(this.canvas[1]);
      
        this.ctx    = [ this.canvas[0].getContext("2d"),this.canvas[1].getContext("2d")];
    }

    this.hextab= ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];
    this.getHexByte    = function(v) { return this.hextab[v>>4]+this.hextab[v&0xf] }
    this.HEX2RGB       = function(hex) { var n=parseInt(hex.slice(1),16); return [(n>>16)&0xFF,(n>>8)&0xFF,n&0xFF] }
    this.RGB2HEX       = function(dec) { return [this.getHexByte(dec[0]),this.getHexByte(dec[1]),this.getHexByte(dec[2])] }
    this.colorDistance = function(a,b) { return Math.sqrt(Math.pow(a[0]-b[0],2)+ Math.pow(a[1]-b[1],2)+Math.pow(a[2]-b[2],2)) }
    this.draw          = function()    { this.draw_rainbow(); this.draw_colormatches() }

    this.color_depth_transform = function(triple,bits)
    {
        p = Math.pow(2, bits[0]/3 );
        q = Math.pow(2, bits[1]/3 );
        var t = [Math.min(255,Math.round( Math.floor(triple[0]/(p/q))*(p-1)/(q-1) ))
                ,Math.min(255,Math.round( Math.floor(triple[1]/(p/q))*(p-1)/(q-1) ))
                ,Math.min(255,Math.round( Math.floor(triple[2]/(p/q))*(p-1)/(q-1) ))]
        return t;
    }
    
    this.calc_nearest = function(x,y,dec_cx)
    {
        for(var i=0;i<this.dec_pal.length;i++)
            for(var j=0;j<this.dec_near_col.length;j++)
            {
                var cd = [this.colorDistance(dec_cx,this.dec_pal[i]),this.colorDistance(this.dec_near_col[i],this.dec_pal[i])]
                if( cd[0] <  cd[1] )
                {
                    this.dec_near_col[i] = dec_cx; 
                    this.dec_near_pos[i] = [[x,y]];
                }
                else if(cd[0] ==  cd[1])
                    this.dec_near_pos[i][ this.dec_near_pos[i].length ] = [x,y];
            }
    }    

    this.draw_rainbow = function()
    {
        update_param();
        this.clear_layer(0);
        this.dec_pal      = [];
        this.dec_near_col = [];
        this.dec_near_pos = [];
        var width  = this.canvas[0].width;
        var height = this.canvas[0].height;

        // initialise color arrays
        for(var i=0;i<this.hex_pal.length;i++)
        {
            this.dec_pal[i]      = this.HEX2RGB(this.hex_pal[i]);
            this.dec_near_col[i] = [0,0,0];
            this.dec_near_pos[i]  = [0,0];
        }

        for(var y=0;y<height;y++)
        {
            for(var x=0;x<width;x++)
            { 
                var dec_cx = this.sweep_section(x,y,width,height);
                //////////////////////////////////////////////////////
                dec_cx = this.color_depth_transform(dec_cx,[24,this.color_depth]);  // Color depth modifier
                //////////////////////////////////////////////////////
                var hex_cx = this.RGB2HEX(dec_cx);
                this.drawPixel(this.ctx[0], x, y, '#'+hex_cx.join(""));
                this.calc_nearest(x,y,dec_cx);
            }
        }

        // calculate center location of closest color
        for(var i=0;i<this.dec_near_col.length;i++)
        {
            if(this.dec_near_pos[i].length>1)
            {
                for(var j=0,avg = [0,0] ;j<this.dec_near_pos[i].length;j++)
                {   
                    avg[0] += this.dec_near_pos[i][j][0];
                    avg[1] += this.dec_near_pos[i][j][1];
                }
                this.dec_near_pos[i][0][0] = avg[0]/this.dec_near_pos[i].length;
                this.dec_near_pos[i][0][1] = avg[1]/this.dec_near_pos[i].length;
            }
        }
        bUpdate = true;     // allow new updates
    }

    this.draw_colormatches = function()
    {
        update_param();
        this.clear_layer(1);
        var width  = this.canvas[0].width;
        var height = this.canvas[0].height;
        this.ctx[1].clearRect(0, 0, width, height);
    
        for(var i=0;i<this.dec_near_col.length;i++)
        {
            var x = this.dec_near_pos[i][0][0];
            var y = this.dec_near_pos[i][0][1];
            var hex_cx = this.RGB2HEX(this.dec_near_col[i]);

            this.ctx[1].beginPath();
            this.ctx[1].arc(x, y, this.dot_size, 0, 2 * Math.PI);
            this.ctx[1].lineWidth=1;
            this.ctx[1].strokeStyle = "#000000";
            this.ctx[1].stroke();
            this.ctx[1].fillStyle = '#'+hex_cx.join("")
            this.ctx[1].fill();

            this.ctx[1].fillStyle = '#FFF'
            this.ctx[1].font = (this.dot_size*1.4)+"px Arial bold";
            this.ctx[1].textAlign = "center"; 
            this.ctx[1].textBaseline = "middle";
            this.ctx[1].fillText(i , x, y);
        }
    }

    this.sweep_section = function(x,y,width,height)
    {
        var fac_x = x/width;
        var fac_y = y/height;
        var sec   = Math.floor(fac_x*this.sec_n[0]);
        var sec_x = fac_x*this.sec_n[0]-sec;
        sec += fac_y>0.5?this.sec_n[1]:0;
        var toRad = function(angle) { return angle * (Math.PI / 180) }

        if(this.bDebug) this.debug_save({"x":x,"y":sec_x*(width/this.sec_n[0])});
        ////////////////////////////////////////////////////////////////
        if(sec & 1) sec_x += 0.22*Math.sin(toRad(180+180*sec_x));     //  Bend x
        else        sec_x += 0.22*Math.sin(toRad(180*sec_x));         //
        ////////////////////////////////////////////////////////////////
        if(this.bDebug) this.debug_save({"x":x,"y":sec_x*(width/this.sec_n[0])});

        var dec_y = fac_y*2>1?1:fac_y*2;
        var inc_y = fac_y*2-1;
        return this.calc_section(sec,sec_x,inc_y,dec_y);
    }

    this.calc_section = function(sec,sec_x,inc_y,dec_y)
    {
        function r(v) { return Math.floor(v) }
        var drk = {  "up":r(sec_x*255*dec_y)
                    ,"dn":r(255*(1-sec_x)*dec_y)
                    ,"max":255*dec_y,"min":0
                    ,"uh0":r(sec_x*128*dec_y)
                    ,"uh1":r(256*sec_x*dec_y)
                    ,"dh0":r((128-sec_x*128)*dec_y)
                    ,"dh1":r((251-sec_x*128)*dec_y)
        }
        var lgt = {  "up":r(drk.up+(255-drk.up)*inc_y)
                    ,"dn":r(drk.dn+(255-drk.dn)*inc_y)
                    ,"max":r(drk.max+(255-drk.max)*inc_y)
                    ,"min":r(drk.min+(255-drk.min)*inc_y)
                    ,"uh0":r(drk.uh0+ inc_y*256 -inc_y*sec_x*128 )
                    ,"dh1":r(drk.dh1+ inc_y*sec_x*128)
        }
        
        switch(sec)
        {
            case 0: return [drk.up,drk.min,drk.max];
            case 1: return [drk.max,drk.min,drk.dn];
            case 2: return [drk.max,drk.up,drk.min];
            case 3: return [drk.dn,drk.max,drk.min];
            case 4: return [drk.min,drk.max,drk.up];
            case 5: return [drk.min,drk.dn,drk.max];
            case 6: return [drk.uh0,drk.uh0,drk.dh1];
            case 7: return [drk.dh0,drk.dh0,drk.uh1];

            case 8: return  [lgt.up,lgt.min,lgt.max];
            case 9: return  [lgt.max,lgt.min,lgt.dn];
            case 10: return [lgt.max,lgt.up,lgt.min];
            case 11: return [lgt.dn,lgt.max,lgt.min];
            case 12: return [lgt.min,lgt.max,lgt.up];
            case 13: return [lgt.min,lgt.dn,lgt.max];
            case 14: return [lgt.uh0,lgt.uh0,lgt.dh1];
            case 15: return [lgt.dn,lgt.dn,lgt.max];

            default: return [255,255,255]
        }
    }
}




/////////////////////////////////////////////////////////////////////////////




function init()
{
    oPALETTE.insert_canvas({"id":"mainPalette","width":550,"height":200});
    oPALETTE.draw();
    oPALETTE.canvas[2] = document.getElementById("Debugcanvas");
    oPALETTE.ctx[2]    = oPALETTE.canvas[2].getContext("2d");
}

function update_param()
{
    if(document.getElementById("param1"))
    {
        oPALETTE.color_depth  = Number(document.getElementById("param1").value);
        document.getElementById("disp_param1").innerHTML 
        = oPALETTE.color_depth + "bits "
        + cap(Math.pow(2, oPALETTE.color_depth/3))+"&nbsp;RGBcols";
    }
    if(document.getElementById("param2"))
    {
        oPALETTE.dot_size     = Number(document.getElementById("param2").value);
        document.getElementById("disp_param2").innerHTML 
        = "dot size "+oPALETTE.dot_size
    }
}

function debug_color(section)
{
    oPALETTE.canvas[2].removeAttribute("hidden");

    var width  = oPALETTE.canvas[2].width;
    var height = oPALETTE.canvas[2].height;
    oPALETTE.clear_layer(2);
    
    for(var i=0;i<=width;i++)
    {
        var v = i*(255/width);
        var dec_cx = [v,v,v];
        var hex_cx = oPALETTE.RGB2HEX(dec_cx);
        var dec_dx = oPALETTE.color_depth_transform(dec_cx,[24,oPALETTE.color_depth*3]);
        var hex_dx = oPALETTE.RGB2HEX(dec_dx);
    }

    var step = 2;
    var trig = {"x":false,"y":false}
    var s = ["<table border=1 style='text-align:center'>","<tr><td>sec_x -></td>","</tr>","</table>"];
    for(var y=0;y<=height;y+=step)
    {
        for(var x=0;x<=width;x+=step)
        {
            var fac_x = x/width;
            var fac_y = y/height;
            var sec   = Math.floor(fac_x*oPALETTE.sec_n[0]);
            var sec_x = fac_x*oPALETTE.sec_n[0]-sec;
            sec += fac_y>0.5?oPALETTE.sec_n[1]:0;
            var dec_y = fac_y*2>1?1:fac_y*2;
            var inc_y = fac_y*2-1;

            if(sec==section)
            {
                // y=0 doesnt work on lower area
                if(!trig.x) trig = {"x":x,"y":y}
                if(x==trig.x) s[2]+= "<tr><td style='background-color:#EEEEEE'>dec_y="+cap(dec_y)+" inc_y="+cap(inc_y)+"</td>"
                if(y==trig.y) s[1]+="<td style='background-color:#EEEEEE'>"+cap(sec_x)+"</td>";
                s[2]+= "<td><small>"+oPALETTE.sweep_section(x,y,width,height).join(",")+"</small></td>";
            }
        }
        if(sec==14)
            s[2]+= "</tr>"
    }
    document.getElementById("debug").innerHTML += s.join("");
}

function cap(v) { return Math.floor(v*100)/100 }
function reload() { oPALETTE.draw() }
function trigger(f,t) { if(bUpdate) { bUpdate = false; setTimeout(f, t) } }
function draw_debug()
{
    if(oPALETTE.bDebug)
    {
        for(var i=0;i<oPALETTE.debug_data.x.length;i++)
            oPALETTE.drawPixel(oPALETTE.ctx[2],oPALETTE.debug_data.x[i],oPALETTE.debug_data.y[i],'black'); 
    }
    else
    {
        document.getElementById("debug").innerHTML = "";
        oPALETTE.canvas[2].setAttribute("hidden","");
    }

 }
</script>

</head>
<body onload="init()">


<button onclick="oPALETTE.bDebug=!oPALETTE.bDebug;debug_color(14);draw_debug()">debug</button>
<div>
    <div id=disp_param1 class="slider" style="width:100px"></div><input type="range" min="1" max="24" value="12" class="slider" id="param1" step=1 style="width:300px;height:20px;margin-top:10px;" oninput="trigger(reload,500)"><br>
    <div id=disp_param2 class="slider" style="width:100px"></div><input type="range" min="1" max="20" value="10" class="slider" id="param2" step=1 style="width:300px;height:20px;margin-top:10px;" oninput="oPALETTE.draw_colormatches()">
</div>


<div id=mainPalette  style="position:absolute;left:8px;top:50px;"></div>

<br>
<canvas hidden id="Debugcanvas" width="550" height="200" style="position: relative;top:0px;left:600px;z-index:0">This browser or document mode doesn't support canvas object</canvas>
<div id=debug></div>


</body>
</html>