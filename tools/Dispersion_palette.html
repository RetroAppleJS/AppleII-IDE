<head>
  <title>Draw Rainbow with Linear gradient</title>
    <style type="text/css">
        body { font-family: 'Courier'; font-size: 12px; }
        #DebugCanvas { border:1px solid black; }
        #MyCanvas { border:1px solid black; }
        #MyCanvas2 { border:1px solid black; }
        .slider { display: inline-block; }
    </style>
<script type="text/javascript">
var bDebug = false;
var canvas,ctx;
var sec_n  = [7,8];         // sections to show vs total sections
var dotsize = 0;
var bUpdate = true;        // screen update trigger
var color_depth_val = 24;   // source color depth
var hex_pal = ["#682172","#68350D","#174A72","#97DD8C","#E7A1F2","#E7B48C"," #97CAF2","#7F7F7F","#7F931A","#2FA87F","#D0567F","#7F6CE5"];

var dec_pal = [];
var dec_near_col = [];
var dec_near_xy  = [];

function drawPixel(context, x, y, color)
{
    var roundedX = Math.round(x);
    var roundedY = Math.round(y);

    context.beginPath();
    context.fillStyle = color || '#000';
    context.fillRect(roundedX, roundedY, 1, 1);
    context.fill();
}

var hextab= ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']; 
function getHexByte(v) { return hextab[v>>4]+hextab[v&0xf] }
function HEX2RGB(hex)  { var n=parseInt(hex.slice(1),16); return [(n>>16)&0xFF,(n>>8)&0xFF,n&0xFF] }
function RGB2HEX(dec)  { return [getHexByte(dec[0]),getHexByte(dec[1]),getHexByte(dec[2])] }
function cap(v) { return Math.floor(v*100)/100 }
var toRad = function(angle) { return angle * (Math.PI / 180) }
function trigger(f,t) { if(bUpdate) { bUpdate = false; setTimeout(f, t) } }

function init()
{
    canvas = [ document.getElementById("MyCanvas"),document.getElementById("MyCanvas2") ];
    ctx = [ canvas[0].getContext("2d"), canvas[1].getContext("2d")];
    canvas[0].addEventListener('click', 
    function(event)
    {
        x = event.offsetX;
        y = event.offsetY;
        if(x==0 && y==0) return;

        var imageData = ctx[0].getImageData(x, y, 1, 1).data;
        rgbaColor = 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';
        document.getElementById("debug").innerHTML += x+" "+y+" "+rgbaColor+"<br>"
    }
    , false);

    update_param();
    draw_rainbow();
}

function color_depth(triple,bits)
{
    p = Math.pow(2, bits[0]/3 );
    q = Math.pow(2, bits[1]/3 );
    var t = [Math.min(255,Math.round( Math.floor(triple[0]/(p/q))*(p-1)/(q-1) ))
            ,Math.min(255,Math.round( Math.floor(triple[1]/(p/q))*(p-1)/(q-1) ))
            ,Math.min(255,Math.round( Math.floor(triple[2]/(p/q))*(p-1)/(q-1) ))]
    return t;
}

function colorDistance(a,b) 
{
    return Math.sqrt( 
        Math.pow( ((a[0]) - (b[0])),2 )
        + Math.pow( ((a[1]) - (b[1])),2 ) 
        + Math.pow( ((a[2]) - (b[2])),2 )
    );
};

function clear_layer(n)
{
    var width  = canvas[0].width;
    var height = canvas[0].height;
    ctx[n].clearRect(0, 0, width, height);
}

function draw_rainbow()
{
    bUpdate = true;     // allow new updates
    update_param();
    clear_layer(0);

    // initialise color arrays
    for(var i=0;i<hex_pal.length;i++)
    {
        dec_pal[i]      = HEX2RGB(hex_pal[i]);
        dec_near_col[i] = [0,0,0];
        dec_near_xy[i]  = [0,0];
    }

    document.getElementById("debug").innerHTML = "";
    canvas[2] = document.getElementById("DebugCanvas");
    canvas[2].setAttribute("hidden","");
    if(bDebug) debug_color();

    var width  = canvas[0].width;
    var height = canvas[0].height;
    for(var y=0;y<height;y++)
    {
        for(var x=0;x<width;x++)
        { 
            var dec_cx = calc_section(x,y,width,height);

            //////////////////////////////////////////////////////
            dec_cx = color_depth(dec_cx,[24,color_depth_val]);  // Color depth modifier
            //////////////////////////////////////////////////////
    
            var hex_cx = RGB2HEX(dec_cx);
            drawPixel(ctx[0], x, y, '#'+hex_cx.join(""));
            nearest(x,y,dec_cx);
        }
    }

    // calculate center location of closest color
    for(var i=0;i<dec_near_col.length;i++)
    {
        if(dec_near_xy[i].length>1)
        {
            for(var j=0,avg = [0,0] ;j<dec_near_xy[i].length;j++)
            {   
                avg[0] += dec_near_xy[i][j][0];
                avg[1] += dec_near_xy[i][j][1];
            }
            dec_near_xy[i][0][0] = avg[0]/dec_near_xy[i].length;
            dec_near_xy[i][0][1] = avg[1]/dec_near_xy[i].length;
        }
    }
    draw_colormatches();
}

function draw_colormatches()
{
    update_param();
    clear_layer(1);
    var width  = canvas[0].width;
    var height = canvas[0].height;
    ctx[1].clearRect(0, 0, width, height);
  
    for(var i=0;i<dec_near_col.length;i++)
    {
        var x = dec_near_xy[i][0][0];
        var y = dec_near_xy[i][0][1];
        var hex_cx = RGB2HEX(dec_near_col[i]);

        ctx[1].beginPath();
        ctx[1].arc(x, y, dotsize, 0, 2 * Math.PI);
        ctx[1].lineWidth=1;
        ctx[1].strokeStyle = "#000000";
        ctx[1].stroke();
        ctx[1].fillStyle = '#'+hex_cx.join("")
        ctx[1].fill();

        ctx[1].fillStyle = '#FFF'
        ctx[1].font = (dotsize*1.4)+"px Arial bold";
        ctx[1].textAlign = "center"; 
        ctx[1].textBaseline = "middle";
        ctx[1].fillText(i , x, y);

    }
}

function nearest(x,y,dec_cx)
{
    for(var i=0;i<dec_pal.length;i++)
    {
        for(var j=0;j<dec_near_col.length;j++)
        {
            var cd = [colorDistance(dec_cx,dec_pal[i]),colorDistance(dec_near_col[i],dec_pal[i])]
            if( cd[0] <  cd[1] )
            {
                dec_near_col[i] = dec_cx; 
                dec_near_xy[i] = [[x,y]];
            }
            else if(cd[0] ==  cd[1])
                dec_near_xy[i][ dec_near_xy[i].length ] = [x,y];
        }
    }
}

function debug_color()
{
    ctx[2] = canvas[2].getContext("2d") ;
    canvas[2].removeAttribute("hidden");

    var width  = canvas[2].width;
    var height = canvas[2].height;
    ctx[2].fillStyle = 'white';
    ctx[2].fillRect(0, 0, width, height);
    
    for(var i=0;i<=width;i++)
    {
        var v = i*(255/width);
        var dec_cx = [v,v,v];
        var hex_cx = RGB2HEX(dec_cx);

        ctx[2].strokeStyle = '#'+hex_cx.join("");
        ctx[2].beginPath();
        ctx[2].moveTo(i, height-50);
        ctx[2].lineTo(i, height-30);
        ctx[2].stroke();

        var dec_dx = color_depth(dec_cx,[24,color_depth_val*3]);
        var hex_dx = RGB2HEX(dec_dx);

        ctx[2].strokeStyle = '#'+hex_dx.join("");
        ctx[2].beginPath();
        ctx[2].moveTo(i, height-20);
        ctx[2].lineTo(i, height);
        ctx[2].stroke();
    }

    var step = 2;
    var trig = {"x":false,"y":false}
    var s = ["<table border=1 style='text-align:center'>","<tr><td>sec_x -></td>","</tr>","</table>"];
    for(var y=0;y<=height;y+=step)
    {
        for(var x=0;x<=width;x+=step)
        {
            var fac_x = x/width;
            var fac_y = y/height;
            var sec   = Math.floor(fac_x*sec_n[0]);
            var sec_x = fac_x*sec_n[0]-sec;
            sec += fac_y>0.5?sec_n[1]:0;
            var dec_y = fac_y*2>1?1:fac_y*2;
            var inc_y = fac_y*2-1;

            if(sec==14)
            {
                // y=0 doesnt work on lower area
                if(!trig.x) trig = {"x":x,"y":y}
                if(x==trig.x) s[2]+= "<tr><td style='background-color:#EEEEEE'>dec_y="+cap(dec_y)+" inc_y="+cap(inc_y)+"</td>"
                if(y==trig.y) s[1]+="<td style='background-color:#EEEEEE'>"+cap(sec_x)+"</td>";
                s[2]+= "<td><small>"+calc_section(x,y,width,height).join(",")+"</small></td>";
            }
        }
        if(sec==14)
            s[2]+= "</tr>"
    }
    document.getElementById("debug").innerHTML += s.join("");
}

function calc_section(x,y,width,height)
{
    var fac_x = x/width;
    var fac_y = y/height;
    var sec   = Math.floor(fac_x*sec_n[0]);
    var sec_x = fac_x*sec_n[0]-sec;
    sec += fac_y>0.5?sec_n[1]:0;

    if(bDebug) drawPixel(ctx[2], x,sec_x*(width/sec_n[0]), 'black');

    ////////////////////////////////////////////////////////////////
    if(sec & 1) sec_x += 0.22*Math.sin(toRad(180+180*sec_x));     //  Bend x
    else        sec_x += 0.22*Math.sin(toRad(180*sec_x));         //
    ////////////////////////////////////////////////////////////////

    if(bDebug) drawPixel(ctx[2], x,sec_x*(width/sec_n[0]), 'black');

    var dec_y = fac_y*2>1?1:fac_y*2;
    var inc_y = fac_y*2-1;
    return section(sec,sec_x,inc_y,dec_y);
}

function section(sec,sec_x,inc_y,dec_y)
{
    function r(v) { return Math.floor(v) }
    var drk = {  "up":r(sec_x*255*dec_y)
                ,"dn":r(255*(1-sec_x)*dec_y)
                ,"max":255*dec_y,"min":0
                ,"uh0":r(sec_x*128*dec_y)
                ,"uh1":r(256*sec_x*dec_y)
                ,"dh0":r((128-sec_x*128)*dec_y)
                ,"dh1":r((251-sec_x*128)*dec_y)
    }
    var lgt = {  "up":r(drk.up+(255-drk.up)*inc_y)
                ,"dn":r(drk.dn+(255-drk.dn)*inc_y)
                ,"max":r(drk.max+(255-drk.max)*inc_y)
                ,"min":r(drk.min+(255-drk.min)*inc_y)
                ,"uh0":r(drk.uh0+ inc_y*256 -inc_y*sec_x*128 )
                ,"dh1":r(drk.dh1+ inc_y*sec_x*128)
    }
    
    switch(sec)
    {
        case 0: return [drk.up,drk.min,drk.max];
        case 1: return [drk.max,drk.min,drk.dn];
        case 2: return [drk.max,drk.up,drk.min];
        case 3: return [drk.dn,drk.max,drk.min];
        case 4: return [drk.min,drk.max,drk.up];
        case 5: return [drk.min,drk.dn,drk.max];
        case 6: return [drk.uh0,drk.uh0,drk.dh1];
        case 7: return [drk.dh0,drk.dh0,drk.uh1];

        case 8: return [lgt.up,lgt.min,lgt.max];
        case 9: return [lgt.max,lgt.min,lgt.dn];
        case 10: return [lgt.max,lgt.up,lgt.min];
        case 11: return [lgt.dn,lgt.max,lgt.min];
        case 12: return [lgt.min,lgt.max,lgt.up];
        case 13: return [lgt.min,lgt.dn,lgt.max];
        case 14: return [lgt.uh0,lgt.uh0,lgt.dh1];
        case 15: return [lgt.dn,lgt.dn,lgt.max];

        default: return [255,255,255]
    }
}

function update_param()
{


    color_depth_val  = Number(document.getElementById("param1").value);
    dotsize          = Number(document.getElementById("param2").value);
    document.getElementById("disp_param1").innerHTML 
        = color_depth_val + "bits "
        //+"("+Math.pow(2,color_depth_val)+"&nbsp;cols) "
        +Math.round( Math.pow(2, color_depth_val/3 )*100)/100+"&nbsp;RGBcols";
    document.getElementById("disp_param2").innerHTML 
        = "dot size "+dotsize
      
}

</script>

</head>
<body onload="init()">
 <button onclick="clear_layer()">clear</button>
 <button onclick="bDebug=!bDebug;draw_rainbow();">debug</button>
<div style="">
<div id=disp_param1 class="slider" style="width:100px"></div><input type="range" min="1" max="24" value="12" class="slider" id="param1" step=1 style="width:300px;height:20px;margin-top:10px;" oninput="trigger(draw_rainbow,500)">
<br>
<div id=disp_param2 class="slider" style="width:100px"></div><input type="range" min="1" max="20" value="10" class="slider" id="param2" step=1 style="width:300px;height:20px;margin-top:10px;" oninput="draw_colormatches()">
</div>
<br>
<div style="position:absolute;left:8px;top:50px;">
    <canvas id="MyCanvas" width="550" height="200" style="position: absolute;top:58px;z-index:0" onclick="click(this)">This browser or document mode doesn't support canvas object</canvas>
    <br><br>
    <canvas id="MyCanvas2" width="550" height="200" style="position: absolute;top:58px;z-index:1">This browser or document mode doesn't support canvas object</canvas>
</div>
<br>
  <canvas hidden id="DebugCanvas" width="550" height="200" style="position: relative;top:0px;left:600px;z-index:0">This browser or document mode doesn't support canvas object</canvas>
  <div id=debug></div>
</body>
</html>
