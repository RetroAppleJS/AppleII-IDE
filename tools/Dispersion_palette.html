<head>
  <title>Draw Rainbow with Linear gradient</title>
    <style type="text/css">
        body { font-family: 'Courier'; font-size: 12px; }
        #DebugCanvas { border:1px solid black; }
        #MyCanvas { border:1px solid black; }
        #MyCanvas2 { border:1px solid black; }
        .slider { display: inline-block; }
    </style>
<script type="text/javascript">
var bDebug = false;
var canvas,ctx;
var sec_n  = [7,8];         // sections to show vs total sections
var bUpdate = false;        // screen update trigger
var color_depth_val = 24;   // source color depth
var hex_pal = ["#682172","#68350D","#174A72","#97DD8C","#E7A1F2","#E7B48C"," #97CAF2","#7F7F7F","#7F931A","#2FA87F","#D0567F","#7F6CE5"];
var dec_pal = [];

var dec_near_col = [];
var dec_near_xy  = [];





//if(bDebug) document.write( "<canvas id=\"DebugCanvas\" width=\"550\" height=\"200\">This browser or document mode doesn't support canvas object</canvas>")

function drawPixel(context, x, y, color)
{
    var roundedX = Math.round(x);
    var roundedY = Math.round(y);

    context.beginPath();
    context.fillStyle = color || '#000';
    context.fillRect(roundedX, roundedY, 1, 1);
    context.fill();
}

var hextab= ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']; 
function getHexByte(v) { return hextab[v>>4]+hextab[v&0xf] }

function HEX2RGB(hex) { var n=parseInt(hex.slice(1),16); return [(n>>16)&0xFF,(n>>8)&0xFF,n&0xFF] }

function init()
{
    canvas = [ document.getElementById("MyCanvas"),document.getElementById("MyCanvas2") ];
    ctx = [ canvas[0].getContext("2d"), canvas[1].getContext("2d")];
    canvas[0].addEventListener('click', 
    function(event)
    {
        x = event.offsetX;
        y = event.offsetY;
        if(x==0 && y==0) return;

        var imageData = ctx[0].getImageData(x, y, 1, 1).data;
        rgbaColor = 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';
        document.getElementById("debug").innerHTML += x+" "+y+" "+rgbaColor+"<br>"
    }
    , false);

    update_param();
    draw_rainbow();
}

function color_depth(triple,bits)
{
    p = Math.pow(2, bits[0]/3 );
    q = Math.pow(2, bits[1]/3 );
    var t = [Math.min(255,Math.round( Math.floor(triple[0]/(p/q))*(p-1)/(q-1) ))
            ,Math.min(255,Math.round( Math.floor(triple[1]/(p/q))*(p-1)/(q-1) ))
            ,Math.min(255,Math.round( Math.floor(triple[2]/(p/q))*(p-1)/(q-1) ))]
    return t;
}

function colorDistance(a,b) 
{
    return Math.sqrt( 
        Math.pow( ((a[0]) - (b[0])),2 )
        + Math.pow( ((a[1]) - (b[1])),2 ) 
        + Math.pow( ((a[2]) - (b[2])),2 )
    );
};

function clear_layer()
{
    var width  = canvas[0].width;
    var height = canvas[0].height;
    ctx[1].clearRect(0, 0, width, height);
    for(var i=0;i<hex_pal.length;i++)
    {
        dec_pal[i] = HEX2RGB(hex_pal[i]);
        dec_near_col[i] = [0,0,0];
        dec_near_xy[i]  = [0,0];
    }
}

function draw_rainbow()
{
    clear_layer();

    if(bDebug)
    {
        canvas[2] = document.getElementById("DebugCanvas");
        ctx[2] = canvas[2].getContext("2d") ;
        canvas[2].removeAttribute("hidden");
        debug_color();
    }
    

    bUpdate = false;     // allow new updates
    var width  = canvas[0].width;
    var height = canvas[0].height;
    for(var y=0;y<height;y++)
    {
        for(var x=0;x<width;x++)
        { 
            var dec_cx = calc_section(x,y,width,height);
            //if(y==150 && x==0) alert(dec_cx.join(",")+" "+color_depth(dec_cx,[24,color_depth_val]).join(",")  );
            //////////////////////////////////////////////////////
            dec_cx = color_depth(dec_cx,[24,color_depth_val]);  // Color depth modifier
            //////////////////////////////////////////////////////
    
            var hex_cx = [getHexByte(dec_cx[0]),getHexByte(dec_cx[1]),getHexByte(dec_cx[2])];
            drawPixel(ctx[0], x, y, '#'+hex_cx.join(""));
            nearest(x,y,dec_cx);
        }
    }

    for(var i=0;i<dec_near_col.length;i++)
    {
        if(dec_near_xy[i].length>1)
        {
            var avg = [0,0];
            for(var j=0;j<dec_near_xy[i].length;j++)
            {   
                avg[0] += dec_near_xy[i][j][0];
                avg[1] += dec_near_xy[i][j][1];
                //if(i==0) document.write(avg[0]+"<br>")
            }
            dec_near_xy[i][0][0] = avg[0]/dec_near_xy[i].length;
            dec_near_xy[i][0][1] = avg[1]/dec_near_xy[i].length;
            
        }

        var x = dec_near_xy[i][0][0];
        var y = dec_near_xy[i][0][1];
        var hex_cx = [getHexByte(dec_near_col[i][0]),getHexByte(dec_near_col[i][1]),getHexByte(dec_near_col[i][2])];
        //document.write("#"+hex_cx.join("")+" "+x+" "+y+"<br>")

        ctx[1].beginPath();
        ctx[1].arc(x, y, 3, 0, 2 * Math.PI);
        ctx[1].lineWidth=1;
        ctx[1].strokeStyle = "#000000";
        ctx[1].stroke();
        ctx[1].fillStyle = '#'+hex_cx.join("")
        ctx[1].fill();
    }
}

function nearest(x,y,dec_cx)
{
    for(var i=0;i<dec_pal.length;i++)
    {
        for(var j=0;j<dec_near_col.length;j++)
        {
            //if(i==0 && j==0 && x==0 && y==0)
            //    document.write(colorDistance(dec_cx,dec_pal[i]) + " < "+colorDistance(dec_near_col[i],dec_pal[i])+"<br>");
            var cd = [colorDistance(dec_cx,dec_pal[i]),colorDistance(dec_near_col[i],dec_pal[i])]

            if( cd[0] <  cd[1] )
            {
                dec_near_col[i] = dec_cx; 
                dec_near_xy[i] = [[x,y]];
            }
            else if(cd[0] ==  cd[1])
            {
                dec_near_xy[i][ dec_near_xy[i].length  ] = [x,y];
            }
        }
    }
}

function debug_color()
{
    var width  = canvas[2].width;
    var height = canvas[2].height;
    ctx[2].fillStyle = 'white';
    ctx[2].fillRect(0, 0, width, height);
    var pc = "";
    
    for(var i=0;i<=width;i++)
    {
        var v = i*(255/width)
        var dec_cx = [v,v,v];
        var hex_cx = [getHexByte(dec_cx[0]),getHexByte(dec_cx[1]),getHexByte(dec_cx[2])];

        ctx[2].strokeStyle = '#'+hex_cx.join("");
        ctx[2].beginPath();
        ctx[2].moveTo(i, height-50);
        ctx[2].lineTo(i, height-30);
        ctx[2].stroke();

        var dec_dx = color_depth(dec_cx,[24,color_depth_val*3]);
        var hex_dx = [getHexByte(dec_dx[0]),getHexByte(dec_dx[1]),getHexByte(dec_dx[2])];

        ctx[2].strokeStyle = '#'+hex_dx.join("");
        ctx[2].beginPath();
        ctx[2].moveTo(i, height-20);
        ctx[2].lineTo(i, height);
        ctx[2].stroke();
        
        pc = hex_cx.join("");
    }

    var step = 2;
    var trig = {"x":false,"y":false}
    var s = ["<table border=1 style='text-align:center'>","<tr><td>sec_x -></td>","</tr>","</table>"];
    for(var y=0;y<=height;y+=step)
    {
        //if(sec==14) s[2]+= "<tr>";
        for(var x=0;x<=width;x+=step)
        {
            var fac_x = x/width;
            var fac_y = y/height;
            var sec   = Math.floor(fac_x*sec_n[0]);
            var sec_x = fac_x*sec_n[0]-sec;
            sec += fac_y>0.5?sec_n[1]:0;
            var dec_y = fac_y*2>1?1:fac_y*2;
            var inc_y = fac_y*2-1;

            if(sec==14)
            {
                // y=0 doesnt work on lower area
                if(!trig.x) trig = {"x":x,"y":y}
                if(x==trig.x) s[2]+= "<tr><td style='background-color:#EEEEEE'>dec_y="+cap(dec_y)+" inc_y="+cap(inc_y)+"</td>"
                if(y==trig.y) s[1]+="<td style='background-color:#EEEEEE'>"+cap(sec_x)+"</td>";
                s[2]+= "<td><small>"+calc_section(x,y,width,height).join(",")+"</small></td>";
            }
        }
        if(sec==14)
            s[2]+= "</tr>"
    }
    document.getElementById("debug").innerHTML += s.join("");
    //document.getElementById("debug").innerHTML = "<textarea>"+s.join("\r\n\r\n")+"</textarea>";
}

function cap(v) { return Math.floor(v*100)/100 }

var toRad = function(angle) { return angle * (Math.PI / 180) }

function calc_section(x,y,width,height)
{
    var fac_x = x/width;
    var fac_y = y/height;
    var sec   = Math.floor(fac_x*sec_n[0]);
    var sec_x = fac_x*sec_n[0]-sec;
    sec += fac_y>0.5?sec_n[1]:0;

    if(bDebug) drawPixel(ctx[2], x,sec_x*(width/sec_n[0]), 'black');

    ////////////////////////////////////////////////////////////////
    if(sec & 1) sec_x += 0.22*Math.sin(toRad(180+180*sec_x));     //  Bend x
    else        sec_x += 0.22*Math.sin(toRad(180*sec_x));         //
    ////////////////////////////////////////////////////////////////

    if(bDebug) drawPixel(ctx[2], x,sec_x*(width/sec_n[0]), 'black');

    var dec_y = fac_y*2>1?1:fac_y*2;
    var inc_y = fac_y*2-1;
    return section(sec,sec_x,inc_y,dec_y);
}

function section(sec,sec_x,inc_y,dec_y)
{
    function r(v) { return Math.floor(v) }
    var drk = {"up":r(sec_x*255*dec_y),"dn":r(255*(1-sec_x)*dec_y),"max":255*dec_y,"min":0
        ,"uh0":r(sec_x*128*dec_y)
        //,"uh1":r(128+sec_x*128*dec_y)
        ,"uh1":r(256*sec_x*dec_y)

        ,"dh0":r((128-sec_x*128)*dec_y)
        ,"dh1":r((251-sec_x*128)*dec_y)
    }
    var lgt = {"up":r(drk.up+(255-drk.up)*inc_y),"dn":r(drk.dn+(255-drk.dn)*inc_y),"max":r(drk.max+(255-drk.max)*inc_y),"min":r(drk.min+(255-drk.min)*inc_y)
        ,"uh0":r(drk.uh0+ inc_y*256 -inc_y*sec_x*128 )
        ,"dh1":r(drk.dh1+ inc_y*sec_x*128)
    }
    
    switch(sec)
    {
        case 0: return [drk.up,drk.min,drk.max];
        case 1: return [drk.max,drk.min,drk.dn];
        case 2: return [drk.max,drk.up,drk.min];
        case 3: return [drk.dn,drk.max,drk.min];
        case 4: return [drk.min,drk.max,drk.up];
        case 5: return [drk.min,drk.dn,drk.max];
        case 6: return [drk.uh0,drk.uh0,drk.dh1];
        case 7: return [drk.dh0,drk.dh0,drk.uh1];

        case 8: return [lgt.up,lgt.min,lgt.max];
        case 9: return [lgt.max,lgt.min,lgt.dn];
        case 10: return [lgt.max,lgt.up,lgt.min];
        case 11: return [lgt.dn,lgt.max,lgt.min];
        case 12: return [lgt.min,lgt.max,lgt.up];
        case 13: return [lgt.min,lgt.dn,lgt.max];
        case 14: return [lgt.uh0,lgt.uh0,lgt.dh1];
        case 15: return [lgt.dn,lgt.dn,lgt.max];

        default: return [255,255,255]
    }
}

function update_param()
{
  if(bUpdate==false) setTimeout(draw_rainbow, 1000);
  bUpdate = true;
  color_depth_val  = Number(document.getElementById("param1").value);
  //draw_rainbow();
  document.getElementById("disp_param1").innerHTML 
      = color_depth_val 
      + "bits ("+Math.pow(2,color_depth_val)+"&nbsp;cols) "
      +Math.round( Math.pow(2, color_depth_val/3 )*100)/100+"&nbsp;RGBcols";
}

</script>

</head>
<body onload="init()">
 <button onclick="clear_layer()">clear</button>
<div style="">
<div id=disp_param1 class="slider" style="width:100px"></div><input type="range" min="1" max="24" value="14" class="slider" id="param1" step=1 style="width:300px;height:20px;margin-top:10px;" oninput="update_param()">
</div>
<br>
<div style="position:absolute;left:8px;top:50px;">
    <canvas id="MyCanvas" width="550" height="200" style="position: absolute;top:28px;z-index:0" onclick="click(this)">This browser or document mode doesn't support canvas object</canvas>
    <br><br>
    <canvas id="MyCanvas2" width="550" height="200" style="position: absolute;z-index:1">This browser or document mode doesn't support canvas object</canvas>
</div>
<br>
  <canvas hidden id="DebugCanvas" width="550" height="200" style="position: relative;top:0px;left:600px;z-index:0">This browser or document mode doesn't support canvas object</canvas>
  <div id=debug></div>
</body>
</html>