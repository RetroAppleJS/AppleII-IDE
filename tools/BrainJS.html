<html>
  <head>
  <title>BrainJS - NEURAL NETWORK TOOL</title>
  <!--
//   ______                   _               _____   ______   
//  |_   _ \                 (_)             |_   _|.' ____ \  
//    | |_) | _ .--.  ,--.   __   _ .--.       | |  | (___ \_| 
//    |  __'.[ `/'`\]`'_\ : [  | [ `.-. |  _   | |   _.____`.  
//   _| |__) || |    // | |, | |  | | | | | |__' |  | \____) | 
//  |_______/[___]   \'-;__/[___][___||__]`.____.'   \______.'       
  -->

  <!-- Pre-trained models -->
  <!-- Won't be required after setting up training model -->
  <script src="../res/MNIST_model_org.js"></script>
  <script src="../res/MNIST_model.js"></script>

  <link rel="stylesheet"        href="../res/COM_MAIN.css">
  <script type="text/javascript" src="../res/COM_MAIN.js"></script>

  <script src="../res/brain_browser.js"></script>

  <meta name="description" content="">
  <meta name="author" content="Freddy Vandriessche">
  <meta charset="utf-8">

<!--
   ██████ ███████ ███████ 
  ██      ██      ██      
  ██      ███████ ███████ 
  ██           ██      ██ 
   ██████ ███████ ███████ 
-->

    <style>
    html {height:100%;font-family:"Arial"; }
    body {height:100%;margin:0px;padding:0px; font-family:Arial; }
    .no_margins { margin:0px 0px 0px; padding:0px 0px 0px 0px 0px; border:0px solid; }
    #sketchpad { border: 5px solid #077; }
    #thumbnail { border: 1px solid #077; }
    #result { font-size: 128pt; float: right; width: 120px; height: 280px; border: 5px solid #fff; text-align: center; line-height: 280px; }
    #main { background-color:#FFFFFF }
    .rbox { border-radius: 10px; background: #F0F0F0; padding: 5px; margin:0px 2px 2px 0px;}
    .brain_logo { width: 100px; height: 100px; float:left; padding:10px }
    .popup_overlay { position: fixed; z-index:1; background: rgba(0, 0, 0, 0.2); transition: opacity 500ms; visibility: hidden; opacity: 0; top: 0; bottom: 0; left: 0; right: 0;  }
    .popup_overlay:target { visibility: visible; opacity: 1; }
    .popup { margin: 70px auto; padding: 20px; background: #fff; border-radius: 5px; width: 40%; position: relative; transition: all 5s ease-in-out;}
    .popup h2 { margin-top: 0; color: #333; }
    .popup .close { position: absolute; top: 20px; right: 30px; transition: all 200ms; font-weight: bold; text-decoration: none;color: #333; }
    .popup .content { max-height: 40%; overflow: auto; }
    </style>
</head>


<script>

//   ██████  ██    ██ ██     ███████ ██    ██ ███    ██  ██████ ████████ ██  ██████  ███    ██ ███████ 
//  ██       ██    ██ ██     ██      ██    ██ ████   ██ ██         ██    ██ ██    ██ ████   ██ ██      
//  ██   ███ ██    ██ ██     █████   ██    ██ ██ ██  ██ ██         ██    ██ ██    ██ ██ ██  ██ ███████ 
//  ██    ██ ██    ██ ██     ██      ██    ██ ██  ██ ██ ██         ██    ██ ██    ██ ██  ██ ██      ██ 
//   ██████   ██████  ██     ██       ██████  ██   ████  ██████    ██    ██  ██████  ██   ████ ███████ 

/////////////////////////////////////////////////////////

var CONF_version="";
var CONF_builddate="";  
var _T = function _T(idx,mod)
{
    this.t = {
        get _language(){ return "NL" }
        ,"title":document.title
        ,"menu_convert":""
        ,"menu_info":"Info/Contact"
        ,"intro":""
        ,"version":(CONF_version?("Version "+CONF_version):"")
        ,"built":(CONF_builddate?("Built "+CONF_builddate):"")
        ,get _(){return this}
    }
    if(idx.length>0 && typeof(this.t[idx])=="undefined") { alert(idx); return "<font color=red>"+idx+"</font>" }
    switch(mod)
    {
        case "cap": return this.t[idx].charAt(0).toUpperCase()+this.t[idx].substring(1,this.t[idx].length);
        case "inv": { var j = {}; for(var i in t) { j[ t[i] ] = i }; return j } // inverse associative
        default: return this.t[idx];
    }
}
function _D(idx) { if(typeof(_T(idx)=="string")) document.write(_T(idx)) }
function _TITLE() {
    var hight_pct = 6;
    var css = "#texturespace {background: #f7f7f7 url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEEAYAAAD5YUI9AAAACXBIWXMAAA4mAAAOJgGi7yX8AAAARElEQVQIHWPYyrxTed9eg3UQWkQHQgtaQGg5JgaohAdUoglC8z+A0mFQBYIpUIEXULoOQgvIQRXIBUElMqASShBaWQwApNg4NPAzQGwAAAAASUVORK5CYII=') repeat center top;font: 62.5%/1 sans-serif;height: 100%;width: 100%;}"
    +"#carvetext {color: transparent;background: #f7f7f7;font: 62.5%/1 sans-serif;stroke: 2px rgba(0,0,0,0.2);background-color: rgba(140,140,140,1);-webkit-background-clip: text;text-shadow: rgba(255,255,255,0.5) 0 5px 6px, rgba(255,255,255,0.2) 1px 3px 3px;transition: text-shadow .1s ease-out, background-color .2s ease-out;}"
    +"#carvetext:hover {color: transparent;background-color: rgba(82,96,117,0.5);-webkit-background-clip: text;text-shadow: rgba(255,255,255,0.5) 0 5px 6px;}"
    +"#carvetext:focus {outline: none;}.slider_main {position: relative;height: 100%;}"
    +".slider_overlay {position: absolute;bottom: 0;left: 0;right: 0;background-color: #F0F0F0;overflow: hidden;width: 100%;height: 85%;transition: .5s ease;}"
    //+".slider_main:hover "
    +".slider_overlay {height: 100%;}"
    +"#topmenu{width:100%;background-color:#f0f0f0}"
    +"ul#minitabs{list-style:none;margin:0;padding:3px 0 0 0;border-left:1px solid #ccc;border-right:1px solid #ccc;border-top:1px solid #ccc;border-bottom:1px solid #ccc;font-weight:700;text-align:left;white-space:nowrap}ul#minitabs li{display:inline;margin:0 3px}ul#minitabs a{text-decoration:none;color:#999}ul#minitabs a#current{border-color:#f60;color:#06f}ul#minitabs a:hover{border-color:#f60;color:#666}"

    return "<style>"+css+".slider_overlay{height: "+(100-hight_pct)+"%}</style>"
    +"<div id=texturespace style='height:100%;width:100%'><center><div id='carvetext'>"
    +"<div style='font-size:5em'>"+(typeof(_T("title"))=="string"?_T("title"):"")+"</div>"
    +"<div style='font-size:1em'>"+(typeof(_T("version"))=="string"?_T("version"):"")
    +" &nbsp; "+(typeof(_T("built"))=="string"?_T("built"):"")+"</div>"
    +"</div></center></div>"
}

function init_gui(_o)
{
  document.getElementById('slider_title').outerHTML = _TITLE();
}

/////////////////////////////////////////////////////////

</script>

<!--
//  ██   ██ ████████ ███    ███ ██      
//  ██   ██    ██    ████  ████ ██      
//  ███████    ██    ██ ████ ██ ██      
//  ██   ██    ██    ██  ██  ██ ██      
//  ██   ██    ██    ██      ██ ███████ 
-->

<body class="slider_main" onload="init_gui();" style="background-color:#B0B0B0">

<div id="slider_title"></div>

<div class="slider_overlay">
  <div id="topmenu">
    <ul id="minitabs">
      <li class=no_margins style=vertical-align:top;>
<!--

    Load training data (images & labels)
-->
    </li>
</ul>
</div>
<div id=main>
    <table>
        <tr>
            <td width="50%" class=no_margins style=vertical-align:top;>

                <svg class=brain_logo version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 200 200">
                    <rect width="100%" height="200px" fill="#F3DF49"/>
                    <text x="10" y="90" style="font-size:25px;">Training</text>
                    <g>
                        <polygon fill="#2E2E2C" points="104.8,110.4 134.1,133.6 134.1,148.7 94.8,163.9 74.3,164.9 58.5,143.7 73.4,123.3"/>
                        <polygon fill="#2E2E2C" points="139.4,148.7 139.4,133.6 134.3,104.4 148.4,103.5 185,126 180.5,153.6 166.4,164"/>
                        <polygon fill="#2E2E2C" points="163.1,167.6 137.3,153.2 101.3,166.6 142.8,177.7 148.4,186.2 155.2,186.2"/>
                        <polygon fill="#2E2E2C" points="111.1,108.3 133.5,127 128.9,105.3"/>
                    </g>
                    <path  d="m105,60l38,35l38,-35l-19,0l0,-35l-38,0l0,35l-19,0z" fill="#2E2E2C"/>
                </svg>
                <div class="rbox" style="width:300px;float:left;">
                    <a class="button" href="#popup1"><img style="width:12px;" src="data:image/gif;base64,R0lGODlhEAAQAPAAAP///2FhYSH5BAEAAAAALAAAAAAQABAAAAIohB0Zx6f84GpogiTzbRheSzldyIEVNYqo+a1m2r7vqdZtCEcVu+tGAQA7"></a>
                    <div id="popup1" class="popup_overlay">
                        <div class="popup">
                            <h2>Load MNIST training models</h2>
                            <a class="close" href="#">&times;</a>
                            <a class="content">
                            Get 2 files from <a href="http://yann.lecun.com/exdb/mnist/" target="_blank">MNIST</a>
                            <ul>
                                <li>taining data (train-images.idx3-ubyte)</li>
                                <li>label dat (train-labels-idx1-ubyte)</li>
                            </ul>
                            
                        </div>
                    </div>
                    <input type="file"  id="dataFile" value="File" onchange="oFile.load(this.id)">
                    <input type="hidden" id=fileID value="">
                </div>
                <br><br>
                <div id="status_2051" class="rbox" style="width:144px;float:left;">
                    <div style="color:#D05050">No images</div>
                </div>
                <div id="status_2049" class="rbox" style="width:144px;float:left;">
                    <div style="color:#D05050">No labels</div>
                </div>
                <br><br><br><br>
                <div id="img_grid"></div>

                <canvas id="mnistCanvas" width="280" height="280">
                    Your browser does not support the HTML5 canvas tag.
                </canvas>
         
            </td>



            <td width="1px" class=no_margins style='background-color:black;padding:1px;'></td>



            <td width="50%" class=no_margins style=vertical-align:top;padding-left:5px>

                <svg class=brain_logo version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 200 200" style="width: 100px; height: 100px;">
                    <rect width="200px" height="200px" fill="#F3DF49"/>
                    <text x="10" y="90" style="font-size:25px;">Inference</text>
                    <g>
                        <polygon fill="#2E2E2C" points="104.8,110.4 134.1,133.6 134.1,148.7 94.8,163.9 74.3,164.9 58.5,143.7 73.4,123.3"/>
                        <polygon fill="#2E2E2C" points="139.4,148.7 139.4,133.6 134.3,104.4 148.4,103.5 185,126 180.5,153.6 166.4,164"/>
                        <polygon fill="#2E2E2C" points="163.1,167.6 137.3,153.2 101.3,166.6 142.8,177.7 148.4,186.2 155.2,186.2"/>
                        <polygon fill="#2E2E2C" points="111.1,108.3 133.5,127 128.9,105.3"/>
                    </g>
                    <path transform="rotate(180 144.217 44.9182)" d="m105,30l38,35l38,-35l-19,0l0,-35l-38,0l0,35l-19,0z" fill="#2E2E2C"/>
                </svg>
                <br><br><br><br><br><br><br>

                <div style="width:420px">
                    <canvas id="sketchpad" width="280" height="280">Sorry, your browser is not supported.</canvas>
                    <div id="result"></div>
                </div>
                <button type="button" id="sketchClearButton">Clear</button>
                <button type="button" id="sketchRecogniseButton">Recognise</button>
                <div id="download"></div>
            </td>
        </tr>
    </table>
</div>

  <script type="text/javascript">

  //  ███    ███  █████  ██ ███    ██ 
  //  ████  ████ ██   ██ ██ ████   ██ 
  //  ██ ████ ██ ███████ ██ ██ ██  ██ 
  //  ██  ██  ██ ██   ██ ██ ██  ██ ██ 
  //  ██      ██ ██   ██ ██ ██   ████

  
var oFile = new FILE();
function FILE()
{
    this.load = function(id)
    {
        var file = document.getElementById(id).files[0];
        if (!file) return;
        this.fread = new FileReader();
        this.fread.id = id;
        this.fread.data_bytes = {};
        this.fread.header_data = {};

        this.fread.readAsArrayBuffer(file);
        document.getElementById("fileID").value = id;

        this.fread.onload = function(event)
        {
            
            var data = new DataView(event.target.result);
            var size = event.target.result.byteLength;
            var bytes = Array(size);

            //var id = event.target.id;
            event.target.data_bytes = {};
            event.target.header_data = {};
            console.log("this.fread.data_bytes("+Object.keys(event.target.data_bytes).length+")");

            var i = 0;
            var magic = data.getUint32(i); i+=4;
            var hd = event.target.header_data[magic] = {};

            if(magic==2051)
            {
                hd.magic = magic;
                hd.count = data.getUint32(i); i+=4;
                hd.rows  = data.getUint32(i); i+=4;
                hd.cols  = data.getUint32(i); i+=4;
                hd.idx   = i;
                display_images(hd,data);

                document.getElementById("status_"+magic).innerHTML = "<small>"+formatBytes(size)+" data loaded<br>"+hd.count+" img, size("+hd.cols+","+hd.rows+")</small>"
            }
            else if(magic==2049)
            {
                hd.magic = magic;
                hd.count = data.getUint32(i); i+=4;
                hd.idx   = i;
                document.getElementById("status_"+magic).innerHTML = "<small>"+formatBytes(size)+" data loaded<br>"+hd.count+" labels</small>"
            }  
            //document.write("count="+t.count+" rows="+t.rows+" cols="+t.cols)
        }
    }
}

function loadFile()
{
    var file = document.getElementById('loadfile').files[0];
    var data = getMnistData(file);

    /*
    var trainData = json;
    var net = new brain.NeuralNetwork({hiddenLayers: [784, 392, 10]});
    net.train(trainData, {
                errorThresh: 0.045,
                log: true,
                logPeriod: 1,
                learningRate: 0.1
            });
        */
}


function readMNIST(start, end)
{
    var dataFileBuffer = document.getElementById('dataFile').files[0];
    var labelFileBuffer = document.getElementById('labelFile').files[0];
    //var dataFileBuffer = fs.readFileSync(__dirname + '\\test_images_10k.idx3-ubyte');
    //var labelFileBuffer = fs.readFileSync(__dirname + '\\test_labels_10k.idx1-ubyte');
    var pixelValues = [];

    for (var image = start; image < end; image++)
    { 
        var pixels = [];
        for (var y = 0; y <= 27; y++)
        {
            for (var x = 0; x <= 27; x++)
            {
                pixels.push(dataFileBuffer[(image * 28 * 28) + (x + (y * 28)) + 16]);
            }
        }

        var imageData  = {};
        imageData["index"] = image;
        imageData["label"] = labelFileBuffer[image + 8];
        imageData["pixels"] = pixels;
        pixelValues.push(imageData);
    }
    return pixelValues;
}


function getMnistData(content)
{
    var lines = content.toString().split('\n');

    var data = [];
    for (var i = 0; i < lines.length; i++) {
        var input = lines[i].split(',').map(Number);

        var output = Array.apply(null, Array(10)).map(Number.prototype.valueOf, 0);
        output[input.shift()] = 1;

        data.push({
            input: input,
            output: output
        });
    }
    return data;
};


function display_images(_hd,_db)
{
    var simplesCount = 20;
    var sizeX = _hd.cols;
    var sizeY = _hd.rows;
    var canvas = document.getElementById("mnistCanvas");
    canvas.height = sizeY*simplesCount;
    var ctx = canvas.getContext("2d");
    var canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    oGRID = new GRID();
    oGRID.header = _hd;
    oGRID.data  = _db;
    oGRID.paint_grid = function(i)
    {
        var idx_offset = this.header.idx + i*this.header.cols*this.header.rows;
        for (var y = 0; y < sizeY; y++)
        {
            var idx = y*this.header.cols;
            for (var x = 0; x < sizeX; x++)
            {
                var pointColor = this.data.getUint8(idx+idx_offset+x);
                var t_idx = x+y*this.header.cols;
                var el = document.getElementById("m"+t_idx);
                el.style.backgroundColor = "#"+RGB2HEX([pointColor,pointColor,pointColor]).join("")
            }
        }
    }
    var styl = "style='display:inline-block;'"
    var js1 = "onclick='var o=document.getElementById(\"img_nav\");var v=Number(o.innerHTML);o.innerHTML=(v<=0?"+(oGRID.header.count-1)+":v-1);oGRID.paint_grid(o.innerHTML);'";
    var js2 = "onclick='var o=document.getElementById(\"img_nav\");var v=Number(o.innerHTML);o.innerHTML=(v>="+oGRID.header.count+"?0:v+1);oGRID.paint_grid(o.innerHTML);'";
    document.getElementById("img_grid").innerHTML = "<div><button "+js1+" "+styl+">prev</button><div "+styl+">&nbsp;&nbsp;<div id=img_nav "+styl+">0</div>&nbsp;&nbsp;</div><button "+js2+" "+styl+">next</button><div>"
    document.getElementById("img_grid").innerHTML += oGRID.build_grid(0,sizeY,sizeX);

    var o=document.getElementById("img_nav");
    oGRID.paint_grid(o.innerHTML);

    for (var i = 0; i < 200; i++)
    {
        var idx_offset = _hd.idx + i*sizeX*sizeY;
        var X_offset = Math.floor(i/10)*sizeX*(sizeY-1)*10;
        for (var y = 0; y < sizeY; y++)
        {
            var idx = y*sizeX;
            for (var x = 0; x < sizeX; x++)
            {
                var position = X_offset + y*canvas.width+x+i*sizeY;
                var pointColor = _db.getUint8(idx+idx_offset+x);
                var pos = position << 2;
                canvasData.data[pos++] = pointColor;
                canvasData.data[pos++] = pointColor;
                canvasData.data[pos++] = pointColor;
                canvasData.data[pos++] = 255;                    
            }
        }
    }
    ctx.putImageData(canvasData, 0, 0);
}

function formatBytes(bytes, decimals = 2)
{
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

var hextab= ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'];
var getHexByte    = function(v) { return this.hextab[v>>4]+this.hextab[v&0xf] }
var HEX2RGB       = function(hex) { var n=parseInt(hex.slice(1),16); return [(n>>16)&0xFF,(n>>8)&0xFF,n&0xFF] }
var RGB2HEX       = function(dec) { return [this.getHexByte(dec[0]),this.getHexByte(dec[1]),this.getHexByte(dec[2])] }


///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////





var bReWrite_org = false;


var oWeightsWalk = new WeightsWalk(json);
oWeightsWalk.min = 0;
oWeightsWalk.max = 0;
oWeightsWalk.bit_trunc = 16;

if(bReWrite_org)
{
    document.getElementById("download").innerHTML = "<button type='button' onclick=\"download('MNIST_model.js',str)\">download</button>"

    oWeightsWalk.process = function()
    {
        if(this.record<this.min) this.min = this.record;
        if(this.record>this.max) this.max = this.record;
    }
    oWeightsWalk.loop();                     // LOOP (min-max)
    var min = oWeightsWalk.min;
    var max = oWeightsWalk.max;

    oWeightsWalk.process = function()
    {
        //return "0x"+rerange(this.record,this.min,this.max,this.bit_trunc).toString(16);
        this.record = rerange(this.record,this.min,this.max,this.bit_trunc);
    }
    oWeightsWalk.loop();
    var str = oWeightsWalk.stringify(json);
}
else
{
    var oWeightsWalk = new WeightsWalk(window["netData"]);
    oWeightsWalk.bit_trunc = 16;
    oWeightsWalk.min = min;
    oWeightsWalk.max = max;
    oWeightsWalk.digits = Math.ceil(Math.log(1<<oWeightsWalk.bit_trunc)/Math.log(10));
}

document.getElementById("download").innerHTML += "<button type='button' onclick=\"document.getElementById('download').innerHTML='<textarea style=width:500;height:250>'+oWeightsWalk.stringify(window[\'netData\'])+'</textarea>'\">dump</button>"


oWeightsWalk.process = function()
{
    this.record = exprange(this.record,this.min,this.max,this.bit_trunc).toPrecision(this.digits);
}
oWeightsWalk.loop();   // LOOP (exrange)
//window["netData"] = json;   // override netData with data from reverse calculation



function rerange(n,min,max,radix)
{
    var r = (1<<radix)-1;
    var v = Math.round((n-min)*r/(max-min))
    return v;         // normal
    //return r-v;       // invert
    //return (v^r)+1;   // 2's complement
    //var h=(r+1)/2;  return Math.abs((v-h)*2-(v>h?1:0)); // symmetric complement
}
function exprange(n,min,max,radix)
{
    var r = (1<<radix)-1;
    return (n/r)*(max-min)+min;             // normal
    //return ((r-n)/r)*(max-min)+min;       // invert
    //return (((n-1)^r)/r)*(max-min)+min;   // inverse 2's complement
    //var h=(r+1)/2;  return ( ((n&1?n:-n)/2+h)  /r)*(max-min)+min; // symmetric complement
}

// test reversibility
/*
var v = 0.17981110155375307;
var rr = rerange(v,min,max,16)
var er = exprange(rr,min,max,16);
alert(v+" > "+rr+" > "+er);
*/

function WeightsWalk(_json)
{
    this.process = function(){  };
    this.data = _json;
    this.record = 0;
    this.loop = function()
    {
        for(var i in this.data.layers)
        {
            console.log("layer["+i+"] len="+Object.keys(this.data.layers[i]).length);
            for(var j in this.data.layers[i])
            {
                if(typeof(this.data.layers[i][j].weights)!="undefined")
                {
                    //console.log("weights len="+Object.keys(this.data.layers[i][j].weights).length)
                    for(var k in this.data.layers[i][j].weights)
                    {
                        this.record = this.data.layers[i][j].weights[k];
                        this.process();
                        this.data.layers[i][j].weights[k] = this.record;
                    }
                }
            }
        }
    }

    this.stringify = function(_json)
    {
        var s = "var min = "+this.min+";\n"
        +"var max = "+this.max+";\n"
        +"var bit_trunc = "+this.bit_trunc+";\n"
        +"window[\"netData\"] = "+JSON.stringify(_json);

        s=s.replace(/"([0-9]+)"/g,"$1")
        .replace(/"(0x[0-9a-f]+)"/g,"$1")
        .replace(/(,256:)/g,"\n$1")
        .replace(/(,512:)/g,"\n$1")
        .replace(/(,768:)/g,"\n$1")
        .replace(/([0-9]+:\{"bias":)/g,"\n$1")

        return s;
    //document.write("<textarea style=width:500px;height:250px>"+s+"</textarea>");
    }
}

function download(filename, text)
{
    var element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}











/* View */
let touchend;
window.addEventListener('load', () => {
    // get the canvas element and its context
    const canvas = document.getElementById('sketchpad');

    const context = canvas.getContext('2d');
    let canvasOffset = getOffsetSum(canvas);

    const footprint = {
        width: 28,
        height: 28
    };

    let isRecognized = false;
    const zoom = 10;

    const clearer = function clearer () {
        context.clearRect(0,0,footprint.width*zoom,footprint.height*zoom);
        // document.getElementById('result').innerText = '';
        isRecognized = false;
    };

    clearer();

    function getOffsetSum(elem) {
        let top=0;
        let left=0;
        while(elem) {
            top = top + parseInt(elem.offsetTop)
            left = left + parseInt(elem.offsetLeft)
            elem = elem.offsetParent
        }

        return {top, left}
    }

    // create a drawer which tracks touch movements
    const drawer = {
        isDrawing: false,
        touchstart(coors) {
            context.beginPath();
            context.lineWidth = 20;
            context.lineCap="round";
            context.moveTo(coors.x-canvasOffset.left, coors.y-canvasOffset.top);
            this.isDrawing = true;
        },
        touchmove(coors) {
            if (this.isDrawing) {
				try {
					clearTimeout(touchend)
				} catch(e) {

				}
                if (isRecognized) {
                    clearer();
                }
                context.lineTo(coors.x-canvasOffset.left, coors.y-canvasOffset.top);
                context.stroke();
            }
        },
        touchend(coors) {
            if (this.isDrawing) {
                this.touchmove(coors);
                this.isDrawing = false;
            }

			touchend = setTimeout(() => {
				recognizeN().then(() => {
					clearer();
				})

			}, 300)
        }
    };
    // create a function to pass touch events and coordinates to drawer
    function draw(event) {
        let type = null;
        // map mouse events to touch events
        switch(event.type){
            case "mousedown":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchstart";
            break;
            case "mousemove":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchmove";
            break;
            case "mouseup":
                    event.touches = [];
                    event.touches[0] = {
                        pageX: event.pageX,
                        pageY: event.pageY
                    };
                    type = "touchend";
            break;
        }

        // touchend clear the touches[0], so we need to use changedTouches[0]
        let coors;
        if(event.type === "touchend") {
            coors = {
                x: event.changedTouches[0].pageX,
                y: event.changedTouches[0].pageY
            };
        }
        else {
            // get the touch coordinates
            coors = {
                x: event.touches[0].pageX,
                y: event.touches[0].pageY
            };
        }
        type = type || event.type
        // pass the coordinates to the appropriate handler
        drawer[type](coors);
    }

    // detect touch capabilities
    const touchAvailable = ('createTouch' in document) || ('ontouchstart' in window);

    // attach the touchstart, touchmove, touchend event listeners.
    if(touchAvailable){
        canvas.addEventListener('touchstart', draw, false);
        canvas.addEventListener('touchmove', draw, false);
        canvas.addEventListener('touchend', draw, false);
    }
    // attach the mousedown, mousemove, mouseup event listeners.
    else {
        canvas.addEventListener('mousedown', draw, false);
        canvas.addEventListener('mousemove', draw, false);
        canvas.addEventListener('mouseup', draw, false);
    }

    window.addEventListener("resize", event => {
        event.preventDefault();
        canvasOffset = getOffsetSum(canvas);
    }, false);

    // prevent elastic scrolling
    document.body.addEventListener('touchmove', event => {
        event.preventDefault();
    }, false); // end body.onTouchMove

    // Clear canvas
    document.getElementById('sketchClearButton').addEventListener('click', event => {
        event.preventDefault();
        clearer();
    }, false)

    // Number recognizer
    function recognizeN() {
		return new Promise((resolve, reject) => {
            if (isRecognized) return;
            let imgData = context.getImageData(0, 0, 280, 280);

            grayscaleImg = imageDataToGrayscale(imgData);
            const boundingRectangle = getBoundingRectangle(grayscaleImg, 0.01);
            const trans = centerImage(grayscaleImg); // [dX, dY] to center of mass

            //console.log(grayscaleImg);
            //console.log(boundingRectangle);
            //console.log(trans);

            // copy image to hidden canvas, translate to center-of-mass, then
            // scale to fit into a 200x200 box (see MNIST calibration notes on
            // Yann LeCun's website)
            const canvasCopy = document.createElement("canvas");
            canvasCopy.width = imgData.width;
            canvasCopy.height = imgData.height;
            const copyCtx = canvasCopy.getContext("2d");
            const brW = boundingRectangle.maxX+1-boundingRectangle.minX;
            const brH = boundingRectangle.maxY+1-boundingRectangle.minY;
            const scaling = 190 / (brW>brH?brW:brH);
            // scale
            copyCtx.translate(canvas.width/2, canvas.height/2);
            copyCtx.scale(scaling, scaling);
            copyCtx.translate(-canvas.width/2, -canvas.height/2);
            // translate to center of mass
            copyCtx.translate(trans.transX, trans.transY);

            copyCtx.drawImage(context.canvas, 0, 0);

            // now bin image into 10x10 blocks (giving a 28x28 image)
            imgData = copyCtx.getImageData(0, 0, 280, 280);
            grayscaleImg = imageDataToGrayscale(imgData);
            console.log(grayscaleImg);

            const nnInput = new Array(784);
            const nnInput2 = [];
            for (var y = 0; y < 28; y++) {
	            for (var x = 0; x < 28; x++) {
	                let mean = 0;
	                for (let v = 0; v < 10; v++) {
	                    for (let h = 0; h < 10; h++) {
	                        mean += grayscaleImg[y*10 + v][x*10 + h];
	                    }
	                }
	                mean = (1 - mean / 100); // average and invert
	                nnInput[x*28+y] = (mean - .5) / .5;
	            }
	        }



            // for visualization/debugging: paint the input to the neural net.
            //if (document.getElementById('preprocessing').checked == true) {
            if (true) {
	            context.clearRect(0, 0, canvas.width, canvas.height);
	            context.drawImage(copyCtx.canvas, 0, 0);
	            for (var y = 0; y < 28; y++) {
	                for (var x = 0; x < 28; x++) {
	                    const block = context.getImageData(x * 10, y * 10, 10, 10);
	                    const newVal = 255 * (0.5 - nnInput[x*28+y]/2);
	                    nnInput2.push(Math.round((255-newVal)/255*100)/100);
	                    for (let i = 0; i < 4 * 10 * 10; i+=4) {
	                        block.data[i] = newVal;
	                        block.data[i+1] = newVal;
	                        block.data[i+2] = newVal;
	                        block.data[i+3] = 255;
	                    }
	                    context.putImageData(block, x * 10, y * 10);
	                }
	            }
	        }


            //console.log(nnInput2);
            const output = nn(nnInput2);
            document.getElementById('result').innerText = output.toString();
            isRecognized = true;
			resolve()
        })

    }
    document.getElementById('sketchRecogniseButton').addEventListener('click', recognizeN, false)
}, false); // end window.onLoad

/* Controller */
  /* Imported model because < 1mb */

// CALCULATE NEURAL NET
function net(input) {
  var netData = window["netData"]
  for (var i = 1; i < netData.layers.length; i++) {
    var layer = netData.layers[i];
    var output = {};

    for (var id in layer) {
      var node = layer[id];
      var sum = node.bias;

      for (var iid in node.weights) {
        sum += node.weights[iid] * input[iid];
      }
      output[id] = 1 / (1 + Math.exp(-sum));
    }
    input = output;
  }
  return output;
}

function getMax(output) {
  let array = []
  for (let i in output) {
	  array.push(output[i])
  }
  const max = Math.max(...array);
  return array.indexOf(max);
}

function nn(input) {
  var output = net(input);

  return getMax(output);
}






/***********/
/* imgUtil */
/***********/







// computes center of mass of digit, for centering
// note 1 stands for black (0 white) so we have to invert.
function centerImage(img) {
    var meanX = 0;
    var meanY = 0;
    var rows = img.length;
    var columns = img[0].length;
    var sumPixels = 0;
    for (var y = 0; y < rows; y++) {
        for (var x = 0; x < columns; x++) {
            var pixel = (1 - img[y][x]);
            sumPixels += pixel;
            meanY += y * pixel;
            meanX += x * pixel;
        }
    }
    meanX /= sumPixels;
    meanY /= sumPixels;

    var dY = Math.round(rows/2 - meanY);
    var dX = Math.round(columns/2 - meanX);
    return {transX: dX, transY: dY};
}

// given grayscale image, find bounding rectangle of digit defined
// by above-threshold surrounding
function getBoundingRectangle(img, threshold) {
    var rows = img.length;
    var columns = img[0].length;
    var minX=columns;
    var minY=rows;
    var maxX=-1;
    var maxY=-1;
    for (var y = 0; y < rows; y++) {
        for (var x = 0; x < columns; x++) {
            if (img[y][x] < threshold) {
                if (minX > x) minX = x;
                if (maxX < x) maxX = x;
                if (minY > y) minY = y;
                if (maxY < y) maxY = y;
            }
        }
    }
    return { minY: minY, minX: minX, maxY: maxY, maxX: maxX};
}

// take canvas image and convert to grayscale. Mainly because my
// own functions operate easier on grayscale, but some stuff like
// resizing and translating is better done with the canvas functions
function imageDataToGrayscale(imgData) {
    var grayscaleImg = [];
    for (var y = 0; y < imgData.height; y++) {
        grayscaleImg[y]=[];
        for (var x = 0; x < imgData.width; x++) {
            var offset = y * 4 * imgData.width + 4 * x;
            var alpha = imgData.data[offset+3];
            // weird: when painting with stroke, alpha == 0 means white;
            // alpha > 0 is a grayscale value; in that case I simply take the R value
            if (alpha == 0) {
                imgData.data[offset] = 255;
                imgData.data[offset+1] = 255;
                imgData.data[offset+2] = 255;
            }
            imgData.data[offset+3] = 255;
            // simply take red channel value. Not correct, but works for
            // black or white images.
            grayscaleImg[y][x] = imgData.data[y*4*imgData.width + x*4 + 0] / 255;
        }
    }
    return grayscaleImg;
}
  </script>
  </div> <!--closing slider_overlay -->

  <div id=debug></div>
</body>
</html>