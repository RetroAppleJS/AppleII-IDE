
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/start/jquery-ui.css" />
<style>
    /* Pen-specific styles */
    * {
    box-sizing: border-box;
    }

    body {
    color: #000;
    font-size: .8rem;
    line-height: 150%;
    font-family: 'Open Sans', sans-serif;
    font-weight: 400;
    }

    h1 {
    font-size: 1.75rem;
    margin: 0 0 0.75rem 0;
    font-family: 'Open Sans', sans-serif;
    font-weight: 700;
    }

    h2 {
    font-family: 'Open Sans', sans-serif;
    font-weight: 700;
    }

    h3 {
    font-family: 'Open Sans', sans-serif;
    font-weight: 700;
    }

    article {
    font-family: 'Open Sans', sans-serif;
    font-weight: 400;
    }

    b {
    font-family: 'Open Sans', sans-serif;
    font-weight: 700;
    }

    i {
    font-family: 'Open Sans', sans-serif;
    font-style: italic;
    }

    code{
    font-family: monospace;
    border: none;
    }

    textarea {
    width: 100%;
    font-family: monospace;
    }

    textarea#grammar, textarea#string, input#lastIndex{
    font-size: .9rem;
        font-family: monospace;
    }

    textarea#grammar, textarea#string{
    font-size: .9rem;
    font-family: monospace;
    padding: 3px 2px 3px 3px;
    margin: 5px 0 0 0;
    }

    textarea#grammar{
        height: 10rem;
    }

    textarea#string{
    height: 5rem;
    }

    button {
    cursor: pointer;
    cursor: hand;
    }

    p.title {
    margin: 0px 0px 3px 0px;
    }

    a.link {
    color: #4284B0;
    text-decoration: none;
    border: none;
    }

    /* Pattern styles */
    #css-table {
        display: table;
        width: 100%;
    }

    #col-1 {
        display: table-cell;
        width: 35%;
        border: 1px solid #4284B0;
    }

    #col-2 {
        display: table-cell;
        width: 35%;
        border-width: 1px 0px;
        border-style: solid;
        border-color: #4284B0;
    }

    #col-3 {
        display: table-cell;
        width: 30%;
        border: 1px solid #4284B0;
    }

    input#exec{
    width: 9rem;
    }

    input#next{
    width: 5rem;
    }

    #more-less {
    color: #0078ae;
    cursor: pointer;
    }

    div#col-1, div#col-2, div#col-3, div#more-less{
    font-family: 'Open Sans', sans-serif;
    font-weight: 400;
        
    }
 </style>
 <div id="css-table">
  <div id="col-1">
     <ul>
      <li><a href="#example-intro">intro</a></li>
      <li><a href="#example-abc">abc</a></li>
      <li><a href="#example-global">global</a></li>
      <li><a href="#example-sticky">sticky</a></li>
      <li><a href="#example-unicode">unicode</a></li>
      <li><a href="#example-debug">debug</a></li>
      <li><a href="#example-float">float</a></li>
      <li><a href="#example-pairs">pairs</a></li>
      <li><a href="#example-html">HTML</a></li>
     </ul>
     <div id="example-intro">
      <p>
      <h4 id="what-is-apg-exp">
       <strong>What is <a class="link" href="https://github.com/ldthomas/apg-js2-exp">apg-exp</a>?
       </strong>
      </h4>

      <ul>
       <li>A pattern matching engine&mdash;an alternative to 
       <a class="link" href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>.</li>
       <li>Designed to have the look and feel of JavaScript's 
       <a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>.</li>
       <li>Powered by <a class="link" href="https://github.com/ldthomas/apg-js2"><b>APG</b></a>.</li>
       <li>
       Pattern matching parsers are generated by <b>APG</b> from an 
       <a class="link" href="https://github.com/ldthomas/apg-js2/blob/master/SABNF.md">SABNF syntax</a>.
       </li>
       <li>
       Pattern matching parsers are full-featured <b>APG</b> parser.
       </li>
      </ul>
      <h4 id="what-is-this-codepen-all-about">
       <strong>What is this CodePen all about?</strong>
      </h4>
      <ul>
       <li>A place to try out <strong>apg-exp</strong>.
       </li>
       <li>Type or paste your SABNF pattern in the <code>grammar</code> box.
       </li>
       <li>Type or paste the string you want to search in the <code>string</code> box.
       </li>
       <li>Click <code>exp.exec(string)</code>.
       </li>
       <li>Play with the options.</li>
      </ul>
      <h4 id="need-some-help">
       <strong>Need some help getting started?</strong>
      </h4>
      <ul>
       <li>Click on any of the tabs above for examples.</li>
       <li>Left to right for easiest to most complex.</li>
      </ul>
      <h4>
       <strong id="more-less">More&hellip;?</strong>
      </h4>
      <div id="more-less-text" title="More To Do">
      <p>There is a lot more to <b>apg-exp</b> than we have been able to cover here.
      </p>
      <ul>
       <li>
       user-written phrase matching code
       </li>
       <li>
       translations with the Abstract Syntax Tree (AST)
       </li>
       <li>
       a very flexible <code>replace()</code> function
       </li>
       <li>
       anchors
       </li>
       <li>
       look around
       </li>
       <li>
       back references
       </li>
       <li>
       multi-line mode
       </li>
      </ul>
      <p>
      Just to name a few.
      To get the full set of features see the user's guide in the <a class="link" href="https://github.com/ldthomas/apg-js2-exp"><b>apg-exp</b> GitHub repo</a>
      and try them out with the <a class="link" href="https://github.com/ldthomas/apg-js2-examples/tree/master/apg-exp">examples</a>.
      </p>
      </div>
     </div>
     <div id="example-abc">
      <p>It's as simple as "abc". This grammar defines the case-insensitive pattern "abc".
      It works just like the RegExp <code>/abc/i</code>.
      Except with SABNF all patterns are named. The first rule defines the entire phrase.
      Its match is returned in <code>result[0]</code> just like RegExp.
      But you will notice that it is also listed under the rule named <code>"phrase"</code>.
      This is often referred to as "named capture" in the regex venacular. 
      </p>
      <p>For a case-sensitive match (like the RegExp <code>/abc/</code>) change it to
      <code>phrase = %s"abc"</code> (<i>important:</i> don't forget to end each rule definition with a newline.)
      </p>
     </div>
     <div id="example-global">
      <p>With the global flag, "g", set, repeated calls to the <code>exec()</code> function
      will look for the next match in the string.
      As you go, look at the <code>last match</code> tab information.
      Notice how <code>lastMatch</code> and the left and right contexts change as you go.
      </p>
      <p>Once you hit the end and there are no more matched phrases to find, <code>lastIndex</code>
      is reset to zero and you can start over.</p>
     </div>
     <div id="example-sticky">
      <p>The sticky flag, "y" works somewhat like the global flag.
      The big difference is that now the <code>lastIndex</code> value acts as an anchor.
      The match <i>must</i> be found beginning at <code>lastIndex</code> or the search fails.
      However, if a match is found <code>lastIndex</code> is advanced just like with the global flag.
      </p>
      <p>Try setting <code>lastIndex</code> to some non-zero values and see what happens.
      </p>
     </div>
     <div id="example-unicode">
      <p>
      One of the big advantages of <b>apg-exp</b> over RegExp is that it gives the user
      complete control over the input and output string character codes.
      You can always input the string to match as a JavaScript string or an integer array of character codes.    
      However, with the unicode flag, <code>"u"</code>, set, <b>apg-exp</b> also returns the results as
      integer arrays of character codes.
      This allows you to work directly with the full range of UTF-32 Unicode.
      </p>
      <p>
      As you click through the matched phrases check out the <code>last match</code>
      tab as well as the <code>result</code> tab. You will see the results displayed in a variety of formats.
      But programmatically, you get the results as interger arrays of character codes.
      </p>
     </div>
     <div id="example-debug">
      <p>
      When RegExp doesn't work as expected
      it is often very hard to figure out why. There are some <a class="link" href="http://www.regexbuddy.com/index.html">tools that can help</a>
      but <b>apg-exp</b> has debugging tools built right into it.
      Syntax errors found in the compile stage are described in a thrown exception message.
      And for errors in the phrase matching stage, we have 
      <b>APG</b>'s tracing facility, 
      </p>
      <p>
      With the debug flag, <code>"d"</code>, set, the tracing facility in the phrase-matching parser is turned on.
      Tracing gives a step-by-step picture of how the parser works its way through the input string,
      often revealing the place where things went wrong quite visibly. Parser tracing is a big topic
      &ndash; too big for here &ndash; and if you are interested in more information take a look at
      <a class="link" href="http://coasttocoastresearch.com/docjs2/apg-lib/trace.html">the documentation </a> and
      some of these <a class="link" href="https://github.com/ldthomas/apg-js2-examples">examples</a>.
      Here we will just walk through some very simple cases.
      </p>
      <ul>
      <li>
      Click the <code>exec()</code> button and the syntax error will pop right up.
      Rule names must be alphanumeric+hyphen and this one begins with a number.
      Delete the "1" so the rule name is just "phrase" and try again.
      <br><br>
      </li>
      <li>
      No luck. Check the <code>debug</code> tab and there isn't much information there either.
      The problem with pattern matching, as opposed to just plain parsing, is that when the match fails,
      the engine keeps stepping forward in the string looking for that first match.
      In this case it never finds one and ends up looking at just the last character.
      Here we need to intervene with some human intuition and ask, "Why doesn't this match at 'abc'?" 
      <br><br>
      </li>
      <li>
      Click the "sticky" flag to anchor the phrase matching and set <code>lastIndex</code> to 3,
      where we want to see what is wrong. Try again and look at the <code>debug</code> tab.
      Now we are getting somewhere. We can see that the <code>TLS</code> operator wants to match "c"
      and it is looking at "x".
      </li>
      </ul>
      <p>
      Okay, these were pretty obvious errors and tracing may not be for you.
      But when you know how to use it, it can be an essential debugging tool for the really tough problems.
      </p>
     </div>
     <div id="example-float">
      <p>
      In this example we will take a look at the more substantial problem of
      matching a floating point number in its most general form.
      </p>
      <ul>
      <li>
      optional "+" or "-" sign
      </li>
      <li>
      decimal number with optional integer and fraction parts
      </li>
      <li>
      optional exponent
      </li>
      <li>
      optional "+" or "-" exponent sign
      </li>
      </ul>
      <p>
      A search of the Internet for such a floating point regular expression turns up many incomplete solutions.
      Its hard to find one that works well.
      Its not that regular expressions can't match the requirements detailed here.
      Its just that you need to be very good at writing and debugging regular expressions to do it.
      </p>
      <p>
      Click through these numbers and see the detailed information you get.
      To actually work with the named phrases progammatically, take a look at this
      <a class="link" href="https://github.com/ldthomas/apg-js2-examples/blob/master/apg-exp/rules.js">example</a>.
      </p>
     </div>
     <div id="example-pairs">
      <p>Matching nested pairs &ndash; parentheses, brackets, HTML tags, etc. &ndash; is often problematic
      because it requires recursion.
      <a class="link" href="http://www.regular-expressions.info/recurse.html">Some regex engines</a>
      support recursion but JavaScript's
      <a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>
      does not.
      With SABNF, recursion is any rule that refers to itself.
      </p>
      <p>
      The grammar at right defines nested pairs of parentheses. Note that the rule <code>P</code> refers to itself.
      The rules <code>L</code> and <code>R</code> have been chosen here to represent parentheses.
      But they can be most anything,
      so long as <code>L</code> can't match any of the same phrases as <code>R</code>. 
      </p>
      <p>
      It is just a short step from nested pairs to adding text between them.
      Click here to see how that is done:<br><br>
      <input id="pairs-text" type="button" value="add text" />
      </p>
     </div>
     <div id="example-html">
      <p>
      HTML tags present an even more difficult problem when we add the condition that the pattern match
      not only the tag form but also the tag names. To do this recursion is required
      along with a special form of back referencing which <b>apg-exp</b> refers to as "parent mode".
      For a detailed description of parent mode back referencing see the back references section
      in the <a class="link" href="https://github.com/ldthomas/apg-js2/blob/master/SABNF.md">SABNF documentation</a>. 
      </p>
      <p>
      In the rule <code>HTML</code> of the grammar to the left is the term <code>\%i%pname</code>.
      This means to do a case-insensitive, parent-mode match to the phrase matched by the previous occurrence
      of <code>name</code>. Parent mode meaning that the occurrence of the rule <code>name</code> in the <code>HTML</code> rule definition
      is to be matched. If <code>name</code> appeared
      any where else in the grammar, any matches to that occurrence would be ignored by this back reference term.
      </p>
     </div>
  </div>
  <div id="col-2">
  <ul>
   <li><a href="#tabs-grammar">home</a></li>
  </ul>
    <div id="tabs-grammar">
    <p>
     <b>grammar:</b> <span class="comment">(SABNF pattern syntax)</span><br>
     <textarea id="grammar" wrap="off" ></textarea>
     </p>
     <p>
      <b>flags:</b> <input type="checkbox" id="global" value="global">global <input type="checkbox" id="sticky"
       value="sticky">sticky <input type="checkbox" id="unicode" value="unicode">unicode <input type="checkbox"
       id="debug" value="debug">debug
     </p>
     <p>
      <b>lastIndex:</b> <input type="text" id="lastIndex" value="0" />
     </p>
     <p>
      <b>string:</b> <span class="comment">(the string to search for patterns in)</span><br>
      <textarea id="string" wrap="off" ></textarea>
     </p>
     <pre>
var exp    = new ApgExp(grammar, flags);
var result = exp.exec(string);
</pre>
     <p>
      <input type="button" id="exec" value="exp.exec(string)" />&nbsp;&nbsp;<input type="button" id="next" value="next" />
     </p>
    </div>
   <div id="col-2-tab-1">
    <article></article>
   </div>
  </div>
  <div id="col-3">
  <ul>
   <li><a href="#tabs-result">result</a></li>
   <li><a href="#tabs-last">last match</a></li>
   <li><a href="#tabs-trace">debug</a></li>
   <li><a href="#tabs-errors">errors</a></li>
  </ul>
   <div id="col-3-tab-1">
  <div id="tabs-result"></div>
  <div id="tabs-last"></div>
  <div id="tabs-trace"></div>
  <div id="tabs-errors"></div>
    <article></article>
   </div>
  </div>
 </div>







 <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>

<script src="../res /APG_v2/web-parser.js" charset="utf-8"></script>


<script>
    var module = {"exports":null}
</script>
<script src="../res /APG_v2/apg-exp/apg-exp.js" charset="utf-8"></script>
    <script src="../res /APG_v2/apg-lib/node-exports.js"></script>



 <script>

var ApgExp = module.exports;



    // the jQuery objects
var $exec, $next, $lastIndex, $global, $sticky, $unicode, $debug, $grammar, $string;
var $tabsErrors, $tabsResult, $tabsLast, $tabsTrace;

// grammars and strings
var grammar = {};
var strings = {};
var g_exp, g_str;

// The sample functions.
var sampleAbc = function() {
  $grammar.val(grammar.abc);
  $string.val(strings.abc);
}
var sampleGlobal = function() {
  $grammar.val(grammar.abc);
  $string.val(strings.global);
  $global.prop("checked", true);
}
var sampleSticky = function() {
  $grammar.val(grammar.abc);
  $string.val(strings.sticky);
  $sticky.prop("checked", true);
}
var sampleUnicode = function() {
  $grammar.val(grammar.abc);
  $string.val(strings.unicode);
  $global.prop("checked", true);
  $unicode.prop("checked", true);
}
var sampleDebug = function() {
  $grammar.val(grammar.debug);
  $string.val(strings.debug);
  $debug.prop("checked", true);
}
var sampleFloat = function() {
  $grammar.val(grammar.float);
  $string.val(strings.float);
  $global.prop("checked", true);
}
var samplePairs = function() {
  $grammar.val(grammar.pairs);
  $string.val(strings.pairs);
}
var samplePairsText = function() {
  $grammar.val(grammar.pairsText);
  $string.val(strings.pairsText);
}
var sampleTags = function() {
  $grammar.val(grammar.html);
  $string.val(strings.html);
}

// The ApgExp constructor.
var setup = function() {
  var flags = "";
  if ($global.prop("checked")) {
    flags += "g";
  }
  if ($sticky.prop("checked")) {
    flags += "y";
  }
  if ($unicode.prop("checked")) {
    flags += "u";
  }
  if ($debug.prop("checked")) {
    flags += "d";
  }
  g_str = $string.val();
  try {
    g_exp = new ApgExp($grammar.val(), flags);
    exec(g_exp, g_str);
  } catch (e) {
    rout = "";
    rout += '<p><i>Note: Use the desktop version of <a class="link" href="https://github.com/ldthomas/apg-js2"><b>APG</b></a>';
    rout += ' for better formatting of these errors';
    rout += ' and better control of the debugging environment for complex grammars.</i>';
    rout += ' HTML entity characters in the grammar syntax may not display correctly here.</p>\n';
    rout += "<h3>grammar source</h3>";
    rout += "<pre>\n";
    rout += $grammar.val();
    rout += "</pre>\n";
    if(e.name === "ApgExpError"){
      rout += e.toHtml();
    }else if(e instanceof Error){
      rout += "<h3>grammar errors</h3>";
      rout += "<pre>\n";
      rout += e.message;
      rout += "</pre>\n";
    }else{
      rout += "<h3>grammar errors</h3>";
      rout += "<pre>\n";
      rout += "unknown exception thrown"
      rout += "</pre>\n";
    }
    $tabsErrors.html(rout);
    $tabsResult.html("");
    $tabsLast.html("");
    $tabsTrace.html("");
    $("#col-3").tabs("option", "active", 3);
  }
}

// exp.exec(string): execute the pattern matching engine
var exec = function() {
  var result, rout, eout, dout, lastIndex;
  var val = $lastIndex.val();
  lastIndex = parseInt(val, 10);
  if(isNaN(lastIndex)){
    alert("lastIndex: "+val+"\nPlease enter a valid integer < string length ("+g_str.length+")");
    return;
  }
  if(g_exp.trace){
    g_exp.trace.filter.operators["<ALL>"] = true;
  }
  g_exp.lastIndex = lastIndex;
  result = g_exp.exec(g_str);
  $lastIndex.val(g_exp.lastIndex);
  rout = "";
  eout = "";
  dout = "";
  if (result) {
    // result
    rout += toHtml(result, g_exp.unicode);
    
    // last match
    eout += toHtml(g_exp, g_exp.unicode);
    
    //next
    if (g_exp.global || g_exp.sticky) {
      $exec.prop("disabled", true);
      $next.prop("disabled", false);
    }
  } else {
    if (g_exp.global || g_exp.sticky) {
      $exec.prop("disabled", false);
      $next.prop("disabled", true);
    }
    rout = "<h3>result = null</h3>";
    eout = "<h3>result = null</h3>";
  }
  
  // debug
  if (g_exp.trace) {
    dout = g_exp.trace.toHtml();
    $("#col-3").tabs("option", "active", 2);
  }
  $tabsResult.html(rout);
  $tabsLast.html(eout);
  $tabsTrace.html(dout);
  $tabsErrors.html("");
}
var toHtml = function(obj, unicode){
  var html = "";
  if(unicode){
    html += obj.toHtml("ascii");
    html += "<br>";
    html += obj.toHtml("decimal");
    html += "<br>";
    html += obj.toHtml("hexidecimal");
    html += "<br>";
    html += obj.toHtml("unicode");
  }else{
    html += obj.toHtml();
  }
  return html;
}
var reset = function(resettab) {
  $exec.prop("disabled", false);
  $next.prop("disabled", true);
  $global.prop("checked", false);
  $sticky.prop("checked", false);
  $unicode.prop("checked", false);
  $debug.prop("checked", false);
  $grammar.val("");
  $string.val("");
  $tabsErrors.html("");
  $tabsResult.html("");
  $tabsLast.html("");
  $tabsTrace.html("");
}
var selectExample = function(event, ui) {
  reset(false);
  $lastIndex.val("0");
  switch (ui.newPanel.selector) {
  case "#example-abc":
    sampleAbc()
    break;
  case "#example-global":
    sampleGlobal()
    break;
  case "#example-sticky":
    sampleSticky()
    break;
  case "#example-unicode":
    sampleUnicode()
    break;
  case "#example-debug":
    sampleDebug()
    break;
  case "#example-float":
    sampleFloat();
    break;
  case "#example-pairs":
    samplePairs();
    break;
  case "#example-html":
    sampleTags();
    break;
  default:
    break;

  }
}
var more = function(){
  $("#more-less-text").dialog("open");
}
$(document).ready(function() {
  // define all grammars
  grammar.abc = 'phrase = "abc"\n';
  grammar.debug = '1phrase = "a" "b" "c"\n';
  grammar.float = "";
  grammar.float += 'float    = [sign] decimal [exponent]\n';
  grammar.float += 'decimal  = (integer ["." [fraction]]) / ("." fraction)\n';
  grammar.float += 'exponent = "e" [esign] exp\n';
  grammar.float += 'sign     = "+" / "-"\n';
  grammar.float += 'esign    = "+" / "-"\n';
  grammar.float += 'integer  = 1*%d48-57\n';
  grammar.float += 'fraction = 1*%d48-57\n';
  grammar.float += 'exp      = 1*%d48-57\n';
  grammar.pairs = "P = L 1*P R / L R\n";
  grammar.pairs += 'L = "("\n';
  grammar.pairs += 'R = ")"\n';
  grammar.pairsText  = "P    = L text 1*(P text) R / L text R\n";
  grammar.pairsText += 'L    = "("\n';
  grammar.pairsText += 'R    = ")"\n';
  grammar.pairsText += 'text = *(%d32-39 / %d42-126)\n';
  grammar.html  = 'tags = %^ HTML %$ ; match only the entire string\n'; 
  grammar.html += 'HTML = "<" name ">" text 1*(HTML text) "</" \\%pname ">"\n'; 
  grammar.html += '     / "<" name ">" text "</" \\%pname ">"\n';
  grammar.html += 'text = *(%d32-59 / %d61-126 / %d9-10 / %d13)\n';
  grammar.html += 'name = 1*(%d65-90 / %d97-122)\n';

  // define all input strings
  strings.abc = "<<<aBc>>>";
  strings.global = "<<<abc---Abc===aBc---ABC>>>";
  strings.sticky = "abcABCAbcaBcabC";
  strings.unicode = "-abc..ABC-";
  strings.debug = "<<<abx>>>";
  strings.float = "1.23e-10###10###.333###-.001e10###+20e-000";
  strings.pairs = "(()())";
  strings.pairsText = "(up 1(up 2( middle 1 )between(middle 2)down 2)down 1)";
  strings.html = '<div>description <b>bold stuff</b>\n  <article> inner text </article>\n</div>';

  // define all jQuery objects
  $exec = $("#exec");
  $next = $("#next");
  $lastIndex = $("#lastIndex");
  $global = $("#global");
  $sticky = $("#sticky");
  $unicode = $("#unicode");
  $debug = $("#debug");
  $grammar = $("#grammar");
  $string = $("#string");
  $tabsErrors = $("#tabs-errors");
  $tabsResult = $("#tabs-result");
  $tabsLast = $("#tabs-last");
  $tabsTrace = $("#tabs-trace");

  // page setup
  $exec.prop("disabled", false);
  $next.prop("disabled", true);
  $exec.click(setup);
  $next.click(exec);
  $("#pairs-text").click(samplePairsText);
  $("#more-less").click(more);
  $("#more-less-text").dialog();
  $("#more-less-text").dialog("close");
  $("#col-1").tabs();
  $("#col-2").tabs();
  $("#col-3").tabs();
  $("#col-1").on("tabsactivate", selectExample);
})

 </script>
